## 外设管理

### 课程大纲
1. 引言
2. 外设驱动程序
3. /dev 目录

---

## 1. 引言

### 外设基础
在计算机系统中，外设包括但不限于：
- **CPU**
- **控制器**
  - 打印机控制器
  - 硬盘控制器
  - 串行连接控制器
- **总线**
- **内存**（RAM、ROM）

### Unix中的外设访问
在Unix系统中，所有外设都被当作文件来访问，这体现了“**一切皆文件**”的理念。

### 示例操作
#### 打印机操作
```c
int fd;
fd = open("/dev/lpr", O_WRONLY);
write(fd, "要打印的内容\r\n", 18);
close(fd);
```

#### 读取硬盘内容
```c
uint8_t block[512];
int fd;
fd = open("/dev/disk2", O_RDONLY);
read(fd, block, sizeof(block));
close(fd);
```
**问题**：这些操作中的“魔法”在哪里？

---

## 2. 外设驱动程序

### 新的文件类型
Unix引入了两种新的特殊文件类型，用于表示外设：
- **字符设备（Character Device）**
  - 标识符：`S_IFCHR` 和 `S_ISCHR()`
  - 名称来源：应为“纯字符模式”
  - 特点：每个字节的读写操作立即传输
- **块设备（Block Device）**
  - 标识符：`S_IFBLK` 和 `S_ISBLK()`
  - 名称来源：应为“块模式”
  - 特点：读写操作经过缓冲区处理后传输
  - 常用于硬盘等设备

### 外设文件的位置
所有外设文件通常位于 `/dev` 目录下。

### 外设编号
外设通过一个 `<主编号, 次编号>` 的组合来标识：
- **主编号（Major Number）**：表示驱动程序的编号（字符或块模式）
- **次编号（Minor Number）**：表示由该驱动管理的具体设备编号
- **数据类型**：`dev_t` 类型，包含主编号和次编号

#### 示例
- **Linux中的磁盘驱动“sd”**：
  - 主编号：8
  - 次编号：磁盘地址（高位） + 分区编号（低位）

### 创建外设文件
```c
int mknod(const char *path, mode_t mode, dev_t dev);
```
- **功能**：创建一个外设文件
- **权限**：仅系统管理员可用
- **状态**：POSIX不支持，现代系统通常自动管理外设文件，无需手动创建

### 外设文件的 `stat` 原语
使用 `stat` 或 `fstat` 获取外设文件的属性：
- **字段 `st_mode`**：使用 `S_ISBLK()` 或 `S_ISCHR()` 判断设备类型
- **字段 `st_rdev`**：包含设备的主编号和次编号
- **字段 `st_dev`**：表示文件所在的设备编号

---

## 3. /dev 目录

### /dev 目录的历史
- **早期**：/dev 目录由系统管理员手动管理，使用 `mknod` 命令或 `MAKEDEV` 脚本添加/删除外设文件。

### /dev 目录的演变
- **动态管理**：
  - 引入 **devfs** 文件系统，自动创建和删除外设文件。
  - 支持“即插即用”（Plug and Play），允许在无需系统管理员干预下添加/移除设备。
  - 示例：连接新光驱自动在 /dev 下生成对应的设备文件。

### 示例：/dev 目录中的设备文件
```bash
/dev/null          # 空设备，所有写入的数据都会被丢弃
/dev/mem           # 访问整个内存
/dev/random        # 随机数生成器
/dev/sda           # 第一个SATA硬盘
/dev/ttyS0         # 第一个串行端口
```

### 特殊设备文件
- **伪设备（Pseudo-Devices）**：
  - 不对应实际的硬件设备，而是提供特定的服务。
  - 示例：
    - `/dev/null`：所有写入的数据被丢弃，读取时返回EOF。
    - `/dev/mem`：访问物理内存。
    - `/dev/random`：提供随机数生成服务。

### 伪终端（Pseudo-Terminals）
- **用途**：模拟终端，用于如SSH、X-Window等需要终端接口的应用程序。
- **结构**：一对伪终端设备，分别为主端（master）和从端（slave）。
- **工作原理**：
  - 主端由服务程序（如SSH服务器）管理，接收来自网络的数据。
  - 从端由用户程序（如shell、vim）使用，仿佛连接到真实终端。
- **示例应用**：
  - SSH会话
  - 图形化终端窗口
  - 多任务终端管理工具（如screen、tmux）

---

## 4. 外设驱动程序的详细机制

### 驱动程序的定义
- **驱动程序**：一组函数，编译后集成到内核中，负责管理特定类型的外设。
- **驱动表**：内核维护一个驱动程序表，按主编号索引，每个驱动包含不同的函数，如 `open`, `close`, `read`, `write`, `ioctl` 等。

### 驱动请求的处理流程
1. 用户程序调用 `open` 打开外设文件，如 `/dev/lp`。
2. 内核查找驱动表，根据主编号找到对应的驱动。
3. 调用驱动的 `write` 函数，传递次编号和其他参数。
4. 驱动执行相应的操作，并返回结果。

### 字符设备驱动
- **接口函数**：
  - `open`, `close`, `read`, `write`：基本的文件操作函数。
  - `ioctl`：用于执行设备特定的控制操作。
  - **中断处理**：设备完成操作后，触发中断，驱动程序处理后续逻辑。

#### 示例：终端（Teleprinter）驱动
- **功能**：
  - 通过串行连接与终端通信，处理输入输出数据。
  - 管理终端的参数，如波特率、字符位数、奇偶校验等。
  - 响应特殊字符，如删除、停止、挂起、文件结束等。
- **控制命令**：
  - 使用 `stty` 命令修改终端参数，通过 `ioctl` 实现。

### 块设备驱动
- **接口函数**：
  - `open`, `close`：管理文件系统的挂载与卸载。
  - `strategy`：处理读写块的策略，如调度算法（例如电梯算法）。
  - **中断处理**：类似字符设备，用于处理设备完成操作后的逻辑。
- **功能**：
  - 读取或写入磁盘块，管理缓存区（Buffer Cache）中的数据。
  - 优化磁盘访问性能，通过调度算法减少寻道时间。

### 驱动程序的复杂性
- **硬件复杂性**：现代硬件设备（如SCSI、USB、SATA、PCI等）接口复杂，驱动程序需要处理多层协议。
- **共享代码**：不同驱动可能共享部分代码，如硬盘驱动的基本读写逻辑。
- **动态设备管理**：支持设备的热插拔，驱动程序需要能够动态加载和卸载。

---

### 总结

- **外设管理**是操作系统的重要组成部分，通过统一的文件接口访问各种硬件设备。
- **驱动程序**在内核中实现，对不同类型的外设提供特定的操作接口。
- **/dev 目录**作为外设文件的集中管理位置，支持动态和静态设备文件的创建与管理。
- **系统原语与库函数**为用户程序提供了访问外设的多种方式，适应不同的使用需求和场景。
- **现代系统**在外设管理上更加复杂，支持多种总线和动态设备，驱动程序的设计和实现也更为复杂。

---
