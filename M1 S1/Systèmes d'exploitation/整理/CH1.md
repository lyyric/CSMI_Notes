# 简介

**作者**：Pierre David  
**邮箱**：pda@unistra.fr  
**机构**：斯特拉斯堡大学  
**学年**：2024 – 2025  

---

# 目录

1. 课程组织
2. 从早期计算机到操作系统
3. 内核
4. POSIX
5. 追踪系统原语

---

# 课程组织

## 课程主题

本课程的核心主题是：**如何使用操作系统？**

- **在最低层次**：
  - 使用 C 语言调用系统原语
    - 需要具备良好的 C 语言水平
  - 使用 POSIX 原语
    - 国际标准
- **理解系统所处理的概念**
  - 通过使用来理解操作系统的范围和所处理的概念
  - 如：进程、用户、文件等

## 实践部分

- 课程配有实践课程
  - 使用系统原语
  - 多加练习，熟悉概念

---

# 参考书目

- M. Rochkind，《Unix 高级编程》，Dunod 出版社（1991）
- W.R. Stevens，S.A. Rago，《UNIX 环境高级编程》，第 3 版，Addison-Wesley 出版社（2013）
- IEEE 计算机协会，The Open Group，《信息技术标准 - 可移植操作系统接口（POSIX®） - 基本规范》，IEEE Std 1003.1（2017）
  - 在线版本：https://pubs.opengroup.org/onlinepubs/9699919799/

---

# 什么是操作系统？

## 问题提出

如何定义什么是操作系统（OS）？

- **简单，先生：Windows、Linux、FreeBSD 等！**

但真的如此简单吗？

- 如果 Linux 是一个操作系统，那么 Debian、Ubuntu 等是什么？
- 那 Android、iOS 呢？
- QNX、RTLinux、VxWorks 呢？
- Contiki、TinyOS 呢？

顺便问一下……

- 互联网接入盒（如路由器）有操作系统吗？
- X 终端有操作系统吗？
- 智能手表有操作系统吗？
- 暖气片的温控器有操作系统吗？
- 汽车有操作系统吗？

## 结论

- 为了定义什么是操作系统，我们需要回顾历史
  - 操作系统需要解决哪些需求或问题？

---

# 历史回顾

## 早期计算机

**示例**：ENIAC（1946 年）

![ENIAC](https://upload.wikimedia.org/wikipedia/commons/6/6f/Classic_Computer_Science_Photo_--_ENIAC.jpg)

- **在这些计算机上**：
  - **编程**：通过连接各单元的线路
  - **结果**：通过指示灯查看
- **计算机特点**：
  - 非常昂贵（通常只有一台）
  - 编程非常困难（ENIAC 最初有 6 位女程序员，编程需要数周时间）
  - 通过物理接线进行编程
  - 一次只能执行一个程序
  - 没有或很少有外设
- **结论**：没有操作系统

---

## 用钥匙启动

**下一步**：

![PDP-1 控制面板](https://upload.wikimedia.org/wikipedia/commons/4/4f/Pdp-1_control_panel.jpg)

- **计算机控制面板**
  - 通过开关将程序输入内存
  - 通过开关启动程序
  - 通过指示灯读取结果
- **结论**：没有操作系统

---

## 打孔卡片

**打孔卡片**（20 世纪 50 年代初）

![打孔卡片](https://upload.wikimedia.org/wikipedia/commons/9/9b/Blue-punch-card-front-horiz.png)

![IBM 704 与打孔卡片阅读器](https://upload.wikimedia.org/wikipedia/commons/0/0a/IBM_704_Computer.jpg)

- **程序（和数据）的输入设备**
- **引导程序**：启动阅读器，将程序存入内存并开始执行

---

## 监控程序

- **打孔卡片** → 自动化程序输入
- **但是**：
  - 需要操作员人工干预：
    - 将卡片放入阅读器
    - 启动阅读
    - 等待程序结束
    - 获取结果（打印机上）
  - **计算机非常昂贵**：浪费的每一分钟计算时间都很昂贵！
- **因此**：内存中常驻的“监控程序”
  - 一次仍然只运行一个程序
  - 自动化地处理不同程序的运行
  - **批处理**（batch processing）
  - 更方便地访问外设
  - **操作系统的最初萌芽**

---

## 假脱机（Spooling）

- **昂贵的计算机** → 如何更好地提高其利用率？
  - 某些外设（打孔卡阅读器、打印机）很慢
- **解决方案**：
  - **在外设工作时启动计算**
  - **实现外设和计算的并行处理**

---

## 多道程序设计（Multiprogramming）

- **当程序等待 I/O 结果时**，处理器会空闲
  - **解决方案**：利用空闲时间运行其他程序
- **引入多道程序设计** → **监督程序**
  - **监督程序**将多个程序加载到内存中
  - 当当前程序请求 I/O 时，监督程序启动下一个程序
  - 当 I/O 控制器发出 I/O 结束信号时，第一个程序恢复执行
- **示例**：曼彻斯特大学的 Atlas 监督程序（1962 年）

---

## 多道程序设计的问题

- **如何保护程序不互相干扰？**
  - **禁止访问其他程序的变量**
  - **需要内存管理单元（硬件组件）**
- **监督程序如何在 I/O 控制器完成后重新获得控制？**
  - **中断机制**

---

## 电传打字机（Teletype）

![Teletype Model ASR33](https://upload.wikimedia.org/wikipedia/commons/6/6b/ASR-33_Teletype_with_table%2C_cropped.jpg)

- **这是一次革命！**
  - **与计算机交互的根本改变**
  - 不再需要等待卡片处理
  - **通过键盘输入命令**
    - **命令语言**
  - **结果直接打印**
- **交互式使用 ≠ 批处理**

---

## 分时系统（Time-sharing）

- **将多个终端连接到同一台计算机**：
  - 支持多个用户
  - 更好地利用计算机成本
  - 通过直接串行连接或调制解调器连接
  - **给每个用户一种拥有“自己”计算机的感觉**
- **分时系统**
- **示例**：
  - **CTSS**（兼容分时系统）：麻省理工学院（1961 年）
    - IBM 7094，经 IBM 修改，支持最多 32 个用户
  - **STSS**（斯坦福分时系统）：斯坦福大学（1963 年）
    - DEC PDP-1，12 个终端

---

## 分时系统的问题

- **如何在时间片结束时重新获得控制？**
  - **时钟中断机制**
- **如何管理多个用户？**
  - **身份验证和授权**
  - **软件机制**
- **如何防止用户超越其权限？**
  - **特权模式和非特权模式**
  - **在非特权模式下禁止某些指令**
- **示例**：
  - **磁盘访问**：仅限特权模式
  - **用户程序**：在非特权模式下执行
    - **通过系统访问文件**

---

## 系统调用

- **当程序需要执行磁盘访问时**，它进行系统调用：
  - **特殊指令**（根据处理器不同，如 TRAP、SVC、INT 等）
  - **引起**（其中包括）：
    - **切换到特权模式**
    - **程序跳转到特定地址**
      - **该地址是操作系统**
  - **验证参数、权限等**
    - **防止用户超越权限**
  - **执行系统调用请求的操作**

---

## 总结

- **操作系统提供的功能**：
  - **最大化计算机的使用**
    - **利用所有空闲时间**
  - **在多个用户之间共享计算机**
    - **公平地共享硬件资源**
  - **方便访问外设**
    - **提供与硬件的接口**
    - **利用外设的并行性**
  - **允许用户编辑、开发、运行程序**
- **同时提供必要的安全保障**

---

# 内核

## 定义

- **内核**：由实现两个基本目标所需的最小系统原语集合组成
  - **公平地共享资源**
  - **保证数据安全**

## 特点

- **计算机启动**：内核加载到内存中
  - **一直驻留，直到重启、关机或崩溃**
- **内核在特权模式下执行**
  - **敏感代码**
  - **开发、调试困难**
  - **越小越好**
  - **一切能放到别处的都应放到别处**
- **示例**：
  - 对于内核，用户 = 整数
  - `ls -l` 显示登录名
    - **整数和名字的转换由 `ls` 完成**
- **突出内核的概念**
  - **Unix 的重大贡献**

---

## 系统原语

- **哪些功能必须是系统原语？**
  - **进程不能直接访问磁盘**（违反第二个目标）
    - **内核必须提供具有权限的抽象**：文件系统、所有者、访问权限
    - **通过该抽象访问磁盘**
    - **`open` 是一个系统原语**
  - **读取当前时间** → 访问外设
    - **`time` 是一个系统原语**
- **哪些功能不是系统原语？**
  - **`strlen` 计算字节数，读取当前进程的内存（允许）**
    - **因此，`strlen` 不是系统原语**
    - **由于其有用性，我们将其放入库中**
  - **`getlogin` 返回用户的登录名**
    - **该函数通过系统原语获取用户编号，然后通过读取 `/etc/passwd` 文件将编号转换为名字**
    - **因此，`getlogin` 不是系统原语**

---

# POSIX

## 介绍

- **POSIX 委员会**：IEEE
  - IEEE = 电气电子工程师学会（美国协会，制定规范性文本）
- **POSIX** = 可移植操作系统接口
- **IEEE 标准**：IEEE Std 1003.*
- **国际标准**：ISO/IEC 9945
- **首个版本**：1988 年
- **当前版本**：2024 年
- **重大影响**：任何操作系统都不能不兼容 POSIX

## POSIX 的内容

- **POSIX 标准化了许多内容**：
  - **系统原语和库函数**
  - **命令**（`sh`、`ls`、`tr` 等）
  - **扩展**（实时、线程、信号量等）
- **POSIX 没有标准化所有内容**：
  - **实现可以有自己的扩展**
    - **非标准化** → **不可移植**
  - **示例**：`ls` 命令
    - **POSIX 2017**：26 个选项（已经很多了）
    - **GNU（Linux）**：59 个选项（太多了！）
- **编写可移植的程序**：遵守 POSIX
  - 使用课堂提供的手册

---

# 系统原语的接口

- **系统原语**：一组可在 C 中调用的函数，用于访问内核提供的服务
  - **最初**（Unix v6，1975 年）：43 个原语
  - **后续发展**（1980 年代）：
    - 贝尔实验室、AT&T
    - 伯克利大学
    - 商业发展
  - **结果**：
    - 许多分歧 → 不兼容
    - 程序不再可移植
    - 用户不满意
- **需要标准化现有内容**：POSIX

---

# POSIX 的原则

- **POSIX 不区分系统原语和库函数**：
  - **给实现留有自由度**
  - **有时区别很小**
  - **示例**：6 个执行程序的函数（`execv`、`execl`、`execvp`、`execlp`、`execve` 和 `execle`），只有一个是原语，其他 5 个是库函数

## 一般原则

- **POSIX 类型**
- **常量**
- **错误处理**
- **指针类型的参数**

---

# POSIX - 类型

- **Unix 内核使用整数来处理对象**
  - **问题**：可移植性（16/32/64 位？实现？）
- **POSIX 引入了新的类型（使用 `typedef`）**
  - **隐藏实现细节**
  - **程序可移植性**
- **一些示例**：
  - `uid_t`：用户编号
  - `gid_t`：组编号
  - `pid_t`：进程编号
  - `mode_t`：权限
  - `time_t`：当前时间
  - `size_t`：大小，`sizeof` 的结果（由 ISO C 定义）

---

# POSIX - 常量

- **一些原语需要指定操作**
  - **示例**：

    ```c
    r = access("toto", F_OK); // 文件是否存在？
    r = access("toto", X_OK); // 我能执行该文件吗？
    r = access("toto", W_OK); // 我能修改该文件吗？
    r = access("toto", R_OK); // 我能读取该文件吗？
    ```

- **使用常量使程序更具可读性**
- **常量定义在头文件中**（如 `unistd.h`）

---

# POSIX - 错误处理

- **在错误情况下，原语**：
  - 返回 `-1`
  - 将错误代码放入 `errno` 变量
- **`errno.h` 文件中定义了错误代码**
- **示例**：

  ```c
  int fd;
  fd = open("toto", O_RDONLY);
  if (fd == -1)
  {
      perror("open toto");
      exit(1);
  }
  ```

- **建议**：
  - 始终检查原语的返回值
  - 显示错误原因

---

# POSIX - 指针类型的参数

- **一些原语返回比简单整数更复杂的结果**
  - **参数类型为指针（指向要填充的对象）**
- **示例**：
  - `int stat(const char *path, struct stat *stbuf);`
    - **将文件的属性返回到 `stbuf` 指向的位置**
- **指向的内存位置必须存在！**
  - **正确**：

    ```c
    struct stat stbuf;
    if (stat("toto", &stbuf) == -1)
    {
        // 错误处理
    }
    ```

  - **错误**：

    ```c
    struct stat *stbuf;
    if (stat("toto", stbuf) == -1)
    {
        // 错误处理
    }
    ```

    - 未初始化的指针，内核将在内存中的某个未知位置写入结果

---

# 追踪系统原语

- **在许多系统上，可以“追踪”一个进程所执行的系统原语**
- **非 POSIX 标准的命令**：
  - **Linux**：`strace` 命令
  - **FreeBSD**：`truss` 命令

## 示例（在 Linux 上）：

```bash
$ strace cp README test
```

- **输出显示了 `cp` 命令执行的系统调用**

- **`strace` 的用途**：
  - 发现系统原语
  - 理解系统命令的工作原理（如果它们很简单）
  - 区分系统原语和库函数
    - `strace` 是放置在内核边界的“间谍”
    - 因此，不显示库函数
  - 调试自己的程序
    - 例如，“奇怪，我的程序在到达某函数调用之前就结束了”
- **不要犹豫，使用 `strace` 命令！**

---

# 结束

以上是本课程的组织和内容，旨在帮助您深入理解操作系统内核的工作原理。