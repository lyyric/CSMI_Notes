**练习2**

本练习的目标是并行化在点云中搜索某个位置 \((X, Y, Z)\) 的最近点。点云中每个点的坐标将随机生成，且每个点必须位于盒子 \([0, 1] \times [0, 1] \times [0, 1]\) 内。用于搜索的参考位置为坐标 \(P = (0.5, 0.5, 0.5)\)。

1. **定义一个 `Point` 类，包含以下属性：**
   - **三个实数**：表示点的坐标（或一个包含三个实数的数组）。
   - **一个整数**：表示点云中点的唯一标识符。

   可根据需要添加构造函数、访问器/修改器和其他方法。

2. **添加一个方法，允许为此类定义一个 MPI 派生类型。** 对该 MPI 派生类型的功能进行一些简单的验证。

3. **设 `nproc` 为进程数，`N` 为一个正整数。** 进程 0 首先定义一个由 `nproc × N` 个点组成的点云。该点云将由一个 `Point` 数组表示，每个点的标识符为该点在数组中的索引。

4. **使用 `MPI_Scatter` 和派生类型，将点云分布到所有进程上。**

5. **每个进程处理其接收到的点，找到距离参考点最近的点。** 提示：考虑定义一个 `distance(...)` 方法。

6. **每个进程将最近点的标识符发送回进程 0。**

7. **进程 0 从接收到的点中（通过标识符确定）寻找全局最近的点，并显示结果。**