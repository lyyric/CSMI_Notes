### 二叉搜索树（BST）及其操作

---

#### **一、二叉搜索树的定义**

- **二叉搜索树**是一种二叉树结构，每个节点最多有两个子节点（左子节点和右子节点）。  
- 每个节点包含一个键（key），满足以下性质：
  1. 对于任意节点 $x$，左子树中的所有节点 $y$ 都满足：  
     $$ \text{key}[y] < \text{key}[x] $$
  2. 右子树中的所有节点 $z$ 都满足：  
     $$ \text{key}[x] < \text{key}[z] $$

---

#### **二、遍历方式**

##### **1. 中序遍历（Infix traversal）**

中序遍历顺序为：**左子树 → 当前节点 → 右子树**，得到的结果是树中节点的键按升序排列。

**伪代码**：
```plaintext
中序遍历(节点 x):
    如果 x ≠ nil:
        中序遍历(左子节点)
        输出 x.key
        中序遍历(右子节点)
```

**复杂度分析**：
- 中序遍历的成本主要由树的节点个数 $n$ 决定。
- 对于树的每个节点 $x$，递归访问左子树和右子树。
- 时间复杂度为：
  $$ T(n) = T(k-1) + T(n-k) + C $$
  其中 $k$ 为根节点的位置，$C$ 是常数操作成本。

展开后：
$$ T(n) = nC = O(n) $$

---

#### **三、二叉搜索树的基本操作**

##### **1. 查找（搜索）**

- **目标**：查找树中是否存在某个值 $v$。
- **方法**：从根节点开始，递归比较值 $v$ 和当前节点的键：
  - 如果 $v$ 小于当前节点键，则进入左子树；
  - 如果 $v$ 大于当前节点键，则进入右子树；
  - 如果相等，则查找成功。

**时间复杂度**：
- 最坏情况下，需要遍历树的高度 $h$。  
- 如果树是**平衡的**，则 $h \approx \log n$。  
- 最坏情况时间复杂度：$O(h)$。

##### **2. 插入**

- **目标**：在树中插入一个新节点，保持二叉搜索树的性质。
- **方法**：
  - 从根节点开始，递归比较插入值和当前节点的键；
  - 如果插入值小，则进入左子树；
  - 如果插入值大，则进入右子树；
  - 当到达空位置（叶子）时，插入新节点。

**时间复杂度**：
- 同样受树的高度 $h$ 控制，时间复杂度为 $O(h)$。

##### **3. 删除**

删除操作分为三种情况：
1. **删除叶子节点**：直接移除该节点。
2. **删除只有一个子节点的节点**：将该节点的父节点直接连接到其子节点。
3. **删除有两个子节点的节点**：
   - 找到该节点的**中序后继**或**中序前驱**（左子树的最大值或右子树的最小值）。
   - 用中序后继或前驱的值替换该节点，然后递归删除后继或前驱。

**时间复杂度**：
- 最坏情况下为 $O(h)$。

##### **4. 找最大值 / 最小值**

- **最小值**：沿左子树一直查找，直到到达最左节点。
- **最大值**：沿右子树一直查找，直到到达最右节点。

**时间复杂度**：$O(h)$。

##### **5. 找前驱 / 后继**

- **后继**：找到比当前节点大的最小节点。如果有右子树，则为右子树的最小值；否则向上找，直到当前节点是某个父节点的左子节点。
- **前驱**：找到比当前节点小的最大节点，逻辑类似。

**时间复杂度**：$O(h)$。

---

#### **四、平衡性问题与红黑树**

##### **1. 二叉搜索树的高度**

- **平衡树**：树的高度 $h \approx \log n$，如 AVL 树、红黑树。
- **非平衡树**：最坏情况下可能退化为链表，$h = n$。

##### **2. 红黑树**

红黑树是一种二叉搜索树，但加入了一些限制以保持树的近似平衡：
1. 每个节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点（nil）是黑色。
4. 如果一个节点是红色，则它的两个子节点必须是黑色。
5. 从任意节点到其所有叶子的路径上必须有相同数量的黑色节点。

**特点**：
- 红黑树的高度 $h \leq 2 \log(n+1)$，确保了所有操作的时间复杂度为 $O(\log n)$。

---

#### **五、例子与练习**

##### **例 1：构建二叉搜索树**

对于键集合 $\{1, 4, 5, 10, 16, 17\}$，分别构建高度为 2、3、4 和 5 的二叉搜索树。

###### **高度为 2**：
```
        5
       / \
      1   16
         /  \
        10   17
```

###### **高度为 3**：
```
        10
       /  \
      5    16
     /     /  \
    1     10   17
```

###### **高度为 4**：
```
        16
       /  \
      5    17
     / \
    1   10
       /
      4
```

###### **高度为 5**：
```
        1
         \
          5
           \
            10
              \
               16
                 \
                  17
```

---

##### **例 2：插入元素 363**

**问题**：以下序列是否可能是插入过程中的遍历路径？
- a. $2, 252, 401, 398, 330, 344, 397, 363$
- b. $924, 220, 911, 244, 898, 256, 362, 363$
- c. $925, 202, 911, 240, 912, 245, 363$

**判断方法**：
- 路径必须遵循二叉搜索树的性质：每次比较后进入左子树或右子树。
- 插入的最后节点应符合插入位置的逻辑。

###### **答案**：
- a. **可能**。
- b. **可能**。
- c. **不可能**，因为 912 在 245 之后出现在路径中，违反了二叉搜索树的性质。