# 信号处理

**作者**：Pierre David  
**电子邮件**：[pda@unistra.fr](mailto:pda@unistra.fr)  
**机构**：斯特拉斯堡大学  
**学年**：2024 – 2025

---

## 目录

1. 引言
2. 定义与信号相关的动作
3. 信号的并发与屏蔽
4. 等待信号
5. 进程定时器
6. Fork和信号
7. 旧的原语
8. 与硬件中断的类比
9. 总结

---

## 1. 引言

**定义**：信号是内核通知给进程的事件。

### 示例：

- **硬件事件**：
    
    - 断开连接（`SIGHUP`）
    - 按下 `CTRL+C`（`SIGINT`）
- **由于程序操作引发的事件**：
    
    - 内存地址错误（`SIGSEGV`）
    - 非法指令（`SIGILL`）
    - 进程警报（`SIGALRM`）
    - 向无读取者的管道写入（`SIGPIPE`）等
- **内核无关联语义的事件**：
    
    - 用户信号（`SIGUSR1` 和 `SIGUSR2`）
    - 终止信号（`SIGTERM`）
    - 强制终止信号（`SIGKILL`）

信号由整数表示，通常以 `SIG` 开头。

---

### 信号的发送

上述示例展示了三大类：

- **硬件事件**：由内核响应硬件事件发送信号。
- **程序操作引发的事件**：内核在处理器检测到异常后发送信号。
- **无关联语义的事件**：通过 `kill` 系统调用，由进程请求内核发送信号。

---

#### `kill` 系统调用

用于向进程发送信号：

```c
int kill(pid_t pid, int sig);
```

- **权限要求**：必须对目标进程有权限（例如，发送进程与目标进程属于同一用户）。
- **可发送的信号**：任何信号都可以发送，不仅限于无关联语义的信号。

**示例**：

```c
kill(getppid(), SIGINT);
```

---

**Unix 命令 `kill`**

- 示例：`kill -HUP 1234`
- 该命令调用 `kill` 系统调用，将参数转换为信号编号。

---

### 默认动作

当信号通知到进程时，进程会执行默认的动作：

- **终止进程**：
    
    - 示例：按下 `CTRL+C`
    - 示例：`SIGSEGV`（内存地址错误）
    - 某些信号会生成 `core` 文件，以便事后分析内存（例如，使用 `$ gdb a.out core` 进行调试）。可能需要调整 `ulimit -c unlimited`。
- **忽略信号**：
    
    - 示例：子进程终止（`SIGCHLD`）
- **暂停进程执行**：
    
    - 示例：按下 `CTRL+Z`（`SIGTSTP`）
    - 或发送 `SIGSTOP`
- **继续进程执行**：
    
    - 使用作业控制命令 `fg` 或 `bg`（发送 `SIGCONT`）

---

### 默认动作示例

|信号|默认动作|生成 `core` 文件|含义|
|---|---|---|---|
|`SIGALRM`|终止|否|进程报警|
|`SIGCHLD`|忽略|否|子进程终止|
|`SIGCONT`|继续|否|恢复进程（前台/后台）|
|`SIGFPE`|终止|是|无效的算术运算（如除零）|
|`SIGHUP`|终止|否|断开连接|
|`SIGINT`|终止|否|`CTRL+C`|
|`SIGKILL`|终止|否|强制终止进程|
|`SIGPIPE`|终止|否|向无读取者的管道写入|
|`SIGQUIT`|终止|是|`CTRL+\`|
|`SIGSEGV`|终止|是|非法内存访问|
|`SIGSTOP`|暂停|否|暂停进程|
|`SIGTERM`|终止|否|请求终止进程|
|`SIGTSTP`|暂停|否|`CTRL+Z`|
|`SIGUSR1`|终止|否|用户定义信号 1|
|`SIGUSR2`|终止|否|用户定义信号 2|
|`SIGWINCH`|忽略|否|窗口大小改变|

---

### 更改默认动作

默认动作并不总是满足需求，可以为每个信号关联一个特定的动作：

- **`SIG_IGN`**：忽略信号。
- **`SIG_DFL`**：执行默认动作。
- **执行预定义的函数**：当信号到达时，执行事先定义的函数。

---

当信号到达并且关联的动作是执行一个函数时，程序的行为：

- **函数会中断程序的执行**。
- **当函数执行完毕后，程序会从中断的位置继续执行**。

---

## 2. 定义与信号相关的动作

### `sigaction` 函数

用于定义信号到达时的动作：

```c
int sigaction(int sig, const struct sigaction *new, struct sigaction *old);
```

- **`sig`**：要设置的信号编号。
- **`new`**：新的信号处理方式，会被复制到进程的属性中。
- **`old`**：用于保存之前的信号处理方式，如果为 `NULL`，则不读取。

---

### `struct sigaction` 结构

```c
struct sigaction {
    void (*sa_handler)(int); // 信号处理函数指针
    sigset_t sa_mask;        // 在处理信号时要屏蔽的信号集
    int sa_flags;            // 行为修饰标志
    // ... 还有其他字段
};
```

- **`sa_handler`**：指向处理信号的函数，函数接受一个 `int` 类型的参数（信号编号），返回 `void`。可以使用特殊值 `SIG_DFL` 和 `SIG_IGN`。
- **`sa_mask`**：在处理信号时要暂时屏蔽的信号集。
- **`sa_flags`**：行为修饰标志，一般设为 `0`。

---

### 使用示例

```c
void handler(int sig) {
    // 处理信号的代码
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler; // 设置处理函数
    sa.sa_flags = 0;         // 默认标志
    sigemptyset(&sa.sa_mask); // 清空屏蔽的信号集
    sigaction(SIGINT, &sa, NULL); // 设置信号处理
    // 其他代码
    return 0;
}
```

**注意**：不要将 `sa.sa_handler = handler(5);`，这样会调用函数并将返回值赋给 `sa_handler`，这是错误的。

---

## 3. 信号的并发与屏蔽

由于信号的异步性，信号处理可能在程序的任何时刻中断主程序的执行，导致并发问题。

### 示例问题

假设有一个大整数计数器，需要防止在更新过程中被信号处理函数打断。

```c
struct counter {
    uint32_t high;
    uint32_t low;
} c = {0, 0};

void increment(void) {
    if (c.low == UINT32_MAX) {
        c.low = 0;
        c.high++;
    } else {
        c.low++;
    }
}

void handler(int sig) {
    increment();
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);
    // 主循环
    while (...) {
        increment();
    }
    return 0;
}
```

**问题**：如果在 `increment` 函数执行到一半时收到信号，信号处理函数也调用了 `increment`，可能导致计数器的值不正确。

---

### 解决方案

在关键代码段屏蔽信号，防止信号处理函数在此期间打断：

```c
void increment(void) {
    sigset_t new_mask, old_mask;
    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGINT);
    sigprocmask(SIG_BLOCK, &new_mask, &old_mask); // 开始关键区

    if (c.low == UINT32_MAX) {
        c.low = 0;
        c.high++;
    } else {
        c.low++;
    }

    sigprocmask(SIG_SETMASK, &old_mask, NULL); // 结束关键区
}
```

---

### 信号屏蔽函数 `sigprocmask`

用于修改进程的信号屏蔽集：

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

- **`how`**：
    - `SIG_BLOCK`：将信号添加到屏蔽集中。
    - `SIG_UNBLOCK`：从屏蔽集中移除信号。
    - `SIG_SETMASK`：设置新的屏蔽集。

---

### 信号集类型 `sigset_t`

- **`sigset_t`**：表示信号集的类型，通常实现为位图。
- **操作函数**：
    - `sigemptyset(sigset_t *set)`：将信号集清空。
    - `sigfillset(sigset_t *set)`：将所有信号添加到信号集。
    - `sigaddset(sigset_t *set, int signum)`：将指定信号添加到信号集。
    - `sigdelset(sigset_t *set, int signum)`：从信号集中移除指定信号。
    - `sigismember(const sigset_t *set, int signum)`：检查信号是否在信号集中。

---

### 处理多个信号的并发

如果多个信号处理函数操作相同的数据结构，需要在 `struct sigaction` 的 `sa_mask` 字段中指定在处理某个信号时要屏蔽的其他信号。

示例：

```c
void handler_sigint(int sig) {
    // 处理 SIGINT 的代码
}

void handler_sighup(int sig) {
    // 处理 SIGHUP 的代码
}

int main() {
    struct sigaction sa_int, sa_hup;

    sa_int.sa_handler = handler_sigint;
    sa_int.sa_flags = 0;
    sigemptyset(&sa_int.sa_mask);
    sigaddset(&sa_int.sa_mask, SIGHUP); // 处理 SIGINT 时屏蔽 SIGHUP
    sigaction(SIGINT, &sa_int, NULL);

    sa_hup.sa_handler = handler_sighup;
    sa_hup.sa_flags = 0;
    sigemptyset(&sa_hup.sa_mask);
    sigaddset(&sa_hup.sa_mask, SIGINT); // 处理 SIGHUP 时屏蔽 SIGINT
    sigaction(SIGHUP, &sa_hup, NULL);

    // 其他代码
    return 0;
}
```

---

## 4. 等待信号

### 错误的方法：主动等待

使用循环不断检查标志位，属于主动等待，浪费 CPU 资源。

```c
volatile sig_atomic_t signal_received = 0;

void handler(int sig) {
    signal_received = 1;
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);

    while (!signal_received) {
        // 主动等待，浪费资源
    }

    // 处理信号后的操作
    return 0;
}
```

---

### 正确的方法：被动等待

使用 `sigsuspend` 函数进行被动等待：

```c
int sigsuspend(const sigset_t *mask);
```

- **作用**：原子地替换进程的信号屏蔽集，并挂起进程，直到收到信号。
- **注意**：`sigsuspend` 总是返回 `-1`，并设置 `errno` 为 `EINTR`。

示例：

```c
sigset_t mask, old_mask, empty_mask;

sigemptyset(&mask);
sigaddset(&mask, SIGINT);
sigprocmask(SIG_BLOCK, &mask, &old_mask); // 屏蔽 SIGINT

if (!signal_received) {
    sigemptyset(&empty_mask);
    sigsuspend(&empty_mask); // 临时解除屏蔽并等待信号
}

sigprocmask(SIG_SETMASK, &old_mask, NULL); // 恢复原来的屏蔽集

// 处理信号后的操作
```

---

## 5. 进程定时器

当需要在特定时间发送信号时，可以使用以下函数：

- **`alarm`**：
    
    - 原型：`unsigned int alarm(unsigned int seconds);`
    - 在指定的秒数后发送 `SIGALRM` 信号。
    - 只能设置一个定时器，若再次调用，会覆盖之前的定时器。
- **`setitimer`**：
    
    - 设置精度更高的定时器，可以指定微秒级别的时间。
    - 可以选择计时的类型，如真实时间、进程时间等。
    - 可以发送不同的信号，如 `SIGALRM`、`SIGVTALRM`、`SIGPROF`。
- **`timer_create`** 等高级定时器函数：
    
    - 支持纳秒级别的精度。
    - 可以创建多个定时器，指定要发送的信号。

---

## 6. Fork 和信号

在使用 `fork` 创建新进程时，需要注意信号处理的继承关系。

- **继承的属性**：
    
    - **信号处理方式**（通过 `sigaction` 设置）。
    - **信号屏蔽集**（通过 `sigprocmask` 设置）。
- **不继承的属性**：
    
    - **挂起的信号集**（即待处理的信号）。

### 注意事项

- 如果父进程在 `fork` 之后立即向子进程发送信号，可能子进程还未设置好信号处理函数。
- 解决方法：在 `fork` 之前设置好信号处理函数，并在子进程中继承。

---

## 7. 旧的原语

早期的 UNIX 系统中存在一些旧的信号处理函数，如：

- **`signal`**：
    
    - 原型：`void (*signal(int signum, void (*handler)(int)))(int);`
    - 已被 `sigaction` 替代。
- **`pause`**：
    
    - 原型：`int pause(void);`
    - 已被 `sigsuspend` 替代。

虽然这些函数仍然存在并被 POSIX 标准化，但不推荐使用。

---

## 8. 与硬件中断的类比

信号处理与硬件中断有相似之处。

### 硬件中断机制

- **处理器**在执行指令时，如果外设发出中断信号，处理器会在当前指令执行完毕后响应中断。
- **中断向量表**：处理器通过中断向量表找到对应中断号的处理函数地址。
- **中断处理过程**：
    - 保存当前的处理器状态（如程序计数器、堆栈指针等）。
    - 跳转到中断处理函数。
    - 处理完毕后，恢复处理器状态，继续执行被中断的程序。

### 类比

- **信号**由内核或其他进程发送，目标是进程。
- **中断**由硬件设备发送，目标是处理器。

---

## 9. 总结

- 每个进程都有与信号相关的三个属性：
    
    - **信号处理方式**：定义每个信号的处理函数。
    - **信号屏蔽集**：当前被屏蔽的信号集。
    - **挂起的信号集**：已发送但尚未处理的信号集。
- **信号处理的两个阶段**：
    
    1. **发送信号**：将信号添加到进程的挂起信号集中。
    2. **处理信号**：当信号未被屏蔽时，执行对应的处理函数。
- **建议**：
    
    - 在信号处理函数中尽量减少操作，避免并发问题。
    - 使用 `sigsuspend` 进行被动等待，避免资源浪费。
    - 注意在 `fork` 之前设置好信号处理函数。

---

**版权声明**：

- © Pierre David
- 可在 [https://gitlab.com/pdagog/ens](https://gitlab.com/pdagog/ens) 获取
- 本课程幻灯片采用“知识共享署名-非商业性使用 4.0 国际”许可证。
- 许可证副本可在 [https://creativecommons.org/licenses/by-nc/4.0/](https://creativecommons.org/licenses/by-nc/4.0/) 获取。

---