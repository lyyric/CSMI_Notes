以下是一个用 **系统调用** 实现的文件复制程序。它接收两个命令行参数：源文件路径和目标文件路径。程序会将源文件的内容复制到目标文件中（如果目标文件已存在，则覆盖其内容）。

### **代码实现**

```c
#include <fcntl.h>   // open, O_RDONLY, O_WRONLY, O_CREAT
#include <unistd.h>  // read, write, close
#include <stdio.h>   // perror, printf
#include <stdlib.h>  // exit

#define BUFFER_SIZE 4096

void usage(const char *prog_name) {
    printf("Usage: %s <source_file> <destination_file>\n", prog_name);
    exit(1);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        usage(argv[0]);
    }

    const char *source_path = argv[1];
    const char *destination_path = argv[2];

    int fd_in, fd_out;         // 文件描述符
    char buffer[BUFFER_SIZE];  // 缓冲区
    ssize_t bytes_read, bytes_written;

    // 打开源文件（只读模式）
    fd_in = open(source_path, O_RDONLY);
    if (fd_in < 0) {
        perror("Erreur lors de l'ouverture du fichier source");
        exit(1);
    }

    // 打开或创建目标文件（只写模式）
    fd_out = open(destination_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd_out < 0) {
        perror("Erreur lors de l'ouverture ou de la création du fichier cible");
        close(fd_in);
        exit(1);
    }

    // 读取源文件并写入目标文件
    while ((bytes_read = read(fd_in, buffer, BUFFER_SIZE)) > 0) {
        bytes_written = write(fd_out, buffer, bytes_read);
        if (bytes_written != bytes_read) {
            perror("Erreur lors de l'écriture dans le fichier cible");
            close(fd_in);
            close(fd_out);
            exit(1);
        }
    }

    if (bytes_read < 0) {
        perror("Erreur lors de la lecture du fichier source");
    }

    // 关闭文件
    close(fd_in);
    close(fd_out);

    printf("La copie s'est bien déroulée.\n");
    return 0;
}
```

---

### **代码说明**

1. **程序的参数：**
   - 程序需要两个命令行参数：
     - **`argv[1]`**：源文件路径（必须存在）。
     - **`argv[2]`**：目标文件路径（可以存在或不存在）。

   如果参数数量不正确，程序会打印用法说明并退出。

2. **打开文件：**
   - **源文件**：以只读模式打开（`O_RDONLY`）。如果打开失败，程序会退出并打印错误信息。
   - **目标文件**：以只写模式打开。如果文件不存在则创建（`O_CREAT`），如果存在则清空内容（`O_TRUNC`）。

3. **读取和写入：**
   - 使用 `read` 从源文件读取数据块到缓冲区。
   - 使用 `write` 将缓冲区的数据写入目标文件。
   - 检查写入字节数是否等于读取字节数，否则报错。

4. **关闭文件：**
   - 在操作完成后，关闭所有打开的文件描述符，释放资源。

5. **错误处理：**
   - 对每个系统调用（`open`、`read`、`write`、`close`）的返回值进行检查，确保程序不会在错误条件下继续运行。

---

### **编译和执行**

#### **编译命令：**
```bash
gcc -o copy_file copy_file.c
```

#### **执行命令：**
```bash
./copy_file toto titi
```

- **`toto`** 是源文件路径。
- **`titi`** 是目标文件路径。

---

### **验证文件复制**

1. 使用 **`cmp`** 命令比较两个文件是否相同：
   ```bash
   cmp toto titi
   ```

   - 如果文件内容相同，`cmp` 不会输出任何信息。
   - 如果文件不同，`cmp` 会输出第一个差异的位置信息。

2. 示例验证：
   - 假设文件 `toto` 是一个大文件。
   - 运行程序复制后，执行 `cmp toto titi`。
   - 如果没有任何输出，说明文件复制成功且无差异。

---

### **注意事项**
1. **大文件支持：**  
   程序使用缓冲区（`BUFFER_SIZE`）读取文件块，避免一次性加载整个文件以节省内存。可以根据需要调整缓冲区大小。

2. **文件权限：**  
   目标文件的权限被固定为 `0644`（用户可读写，组用户和其他用户只读）。

3. **错误处理：**  
   如果出现任何错误（如文件不存在或无权限访问），程序会适时打印错误信息并退出。

4. **覆盖文件：**  
   如果目标文件已存在，程序会覆盖其内容。如果需要保留文件内容，应添加相应的逻辑。