## 管道管理

### 课程大纲
1. 引言
2. 管道的创建
3. 工作规则
4. 命名管道
5. 重定向

---

## 1. 引言

### 管道的基本概念
管道是Unix系统的一项重大创新。它允许将一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信。

**示例**：
```bash
$ ls -l | wc -l
```
在这个例子中：
- `ls -l` 进程将其输出写入管道。
- `wc -l` 进程从管道中读取数据并进行处理。
- 管道是单向的通信通道。

### 管道的工作机制
- **写入**：`ls` 进程使用 `write` 系统调用将数据写入管道。
  - 如果管道已满，`write` 将阻塞，直到有空间可用。
- **读取**：`wc` 进程使用 `read` 系统调用从管道中读取数据。
  - 如果管道为空，`read` 将阻塞，直到有数据可读。
- **并行运行**：`ls` 和 `wc` 进程同时运行，彼此同步通过管道通信。
- **数据传输**：理论上，没有数据传输的量限制，依赖于管道的缓冲区大小。

---

## 2. 管道的创建

### 使用 `pipe` 系统调用创建管道
```c
int pipe(int tube[2]);
```
- **功能**：创建一个管道，并返回两个文件描述符。
  - `tube[0]`：用于读取数据。
  - `tube[1]`：用于写入数据。

### 管道的文件描述符结构
- **读端 (`tube[0]`)**：
  - 方向：只读
  - 用途：从管道中读取数据
- **写端 (`tube[1]`)**：
  - 方向：只写
  - 用途：向管道中写入数据

### 示例代码
以下是一个简单的示例，展示如何在父子进程间创建和使用管道：

#### 示例 1/6
```c
int tube[2];
pid_t pid = fork();

if (pid == -1) {
    // 错误处理
} else if (pid == 0) {
    // 子进程
    if (pipe(tube) == -1) {
        // 错误处理
    }
    close(tube[0]); // 关闭读端
    fils(tube[1]);   // 子进程使用写端
    close(tube[1]); // 关闭写端
    exit(0);
} else {
    // 父进程
    close(tube[1]); // 关闭写端
    pere(tube[0]);   // 父进程使用读端
    close(tube[0]); // 关闭读端
    if (wait(NULL) == -1) {
        // 错误处理
    }
}
```

#### 示例 2/6 至 6/6
（由于原始笔记中示例 2 到 6 基本相似，主要展示了管道在父子进程中的不同使用方式，这里简化描述）

---

## 3. 工作规则

### 读操作的特殊规则
- **阻塞读取**：
  - `read` 是阻塞性的，当管道为空且没有写入者时，`read` 返回 `0`，表示文件结束（EOF）。
- **部分读取**：
  - `read` 可能只读取到部分数据，尤其是在数据量大于管道缓冲区时。因此，程序应准备好处理部分读取的情况。

### 写操作的特殊规则
- **部分写入**：
  - `write` 的写入量受管道缓冲区大小限制。如果缓冲区已满，`write` 会阻塞，直到有空间可用。
  - 通常情况下，`write` 会尝试写入全部数据，除非被信号中断或发生异常情况。
- **无读者的写入**：
  - 如果向一个没有读取者的管道写入数据，`write` 会发送 `SIGPIPE` 信号，导致写入进程终止。
  - **示例**：
    ```bash
    $ find / | ./a.out
    ```
    如果 `a.out` 进程提前终止，`find` 进程将收到 `SIGPIPE` 信号并终止。

### 管道共享规则
- **多读者与多写者**：
  - 管道允许多个读者和多个写者同时使用，但需小心处理并发读写。
- **检测文件结束**：
  - 当所有写端都关闭时，读端读取到EOF，表示没有更多数据可读。
- **写入数据的原子性**：
  - 对于长度小于或等于 `PIPE_BUF`（POSIX规定最小为512字节）的写入操作，保证原子性，不会与其他写入混淆。
  - 对于长度超过 `PIPE_BUF` 的写入，可能会与其他写入操作交错，导致数据混淆。

### 注意事项
- **调用顺序**：
  - `pipe` 应在 `fork` 之前调用，以确保子进程继承管道的文件描述符。
- **关闭不必要的描述符**：
  - 在父子进程中，关闭各自不需要的文件描述符，防止资源泄漏和意外行为。

---

## 4. 命名管道

### 什么是命名管道？
- **命名管道（FIFO）**：在文件系统中有一个文件名，可以跨进程通信，不需要父子进程关系。
- **与匿名管道的区别**：
  - 匿名管道只能在有共同祖先的进程间使用，通过文件描述符共享。
  - 命名管道像普通文件一样存在，可以被任意进程打开和使用。

### 创建命名管道
```c
int mkfifo(const char *path, mode_t mode);
```
- **参数**：
  - `path`：管道文件的路径名。
  - `mode`：权限模式，类似于普通文件的权限设置。
- **功能**：创建一个类型为FIFO的特殊文件。

### 使用命名管道
- **打开方式**：
  - 使用 `open`、`read`、`write` 和 `close` 操作命名管道，与操作普通文件类似。
- **工作规则**：
  - 在有读者和写者的情况下，管道正常工作。
  - 如果有读者先启动但没有写者，`read` 会阻塞，直到有写者连接。
  - 如果有写者先启动但没有读者，`write` 会阻塞，直到有读者连接。

### 示例代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    const char *fifo_path = "/tmp/myfifo";
    
    // 创建命名管道
    if (mkfifo(fifo_path, 0666) == -1) {
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }
    
    pid_t pid = fork();
    
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程：写入数据到管道
        int fd = open(fifo_path, O_WRONLY);
        if (fd == -1) {
            perror("open write");
            exit(EXIT_FAILURE);
        }
        write(fd, "Hello from child\n", 17);
        close(fd);
        exit(0);
    } else {
        // 父进程：从管道读取数据
        int fd = open(fifo_path, O_RDONLY);
        if (fd == -1) {
            perror("open read");
            exit(EXIT_FAILURE);
        }
        char buffer[128];
        ssize_t bytes = read(fd, buffer, sizeof(buffer) - 1);
        if (bytes > 0) {
            buffer[bytes] = '\0';
            printf("父进程读取到：%s", buffer);
        }
        close(fd);
        wait(NULL);
    }
    
    // 删除命名管道
    unlink(fifo_path);
    
    return 0;
}
```

---

## 5. 重定向

### 如何在管道中进行重定向？
- **示例**：
  ```bash
  $ ls -l | wc -l
  ```
  - **步骤**：
    1. 创建一个匿名管道。
    2. `ls -l` 进程将标准输出重定向到管道的写端。
    3. `wc -l` 进程将标准输入重定向到管道的读端。
  
### 重定向的实现步骤
1. **创建管道**：
   ```c
   int tube[2];
   if (pipe(tube) == -1) {
       perror("pipe");
       exit(EXIT_FAILURE);
   }
   ```
2. **创建子进程**：
   ```c
   pid_t pid = fork();
   if (pid == -1) {
       perror("fork");
       exit(EXIT_FAILURE);
   }
   ```
3. **在子进程中设置写入端**：
   ```c
   if (pid == 0) {
       // 子进程：写入数据
       close(tube[0]); // 关闭读端
       dup2(tube[1], STDOUT_FILENO); // 重定向标准输出到写端
       close(tube[1]); // 关闭写端副本
       execlp("ls", "ls", "-l", NULL); // 执行 ls -l
       perror("execlp");
       exit(EXIT_FAILURE);
   }
   ```
4. **在父进程中设置读取端**：
   ```c
   // 父进程：读取数据
   close(tube[1]); // 关闭写端
   dup2(tube[0], STDIN_FILENO); // 重定向标准输入到读端
   close(tube[0]); // 关闭读端副本
   execlp("wc", "wc", "-l", NULL); // 执行 wc -l
   perror("execlp");
   exit(EXIT_FAILURE);
   ```

### 使用 `dup` 和 `dup2` 进行重定向

#### 使用 `dup` 进行重定向
- **步骤**：
  1. 关闭目标描述符（如标准输出 `1`）。
  2. 打开目标文件，系统会自动使用最小可用描述符（此时为 `1`）。
- **示例代码**：
  ```c
  int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  if (fd == -1) {
      perror("open");
      exit(EXIT_FAILURE);
  }
  if (close(STDOUT_FILENO) == -1) {
      perror("close");
      exit(EXIT_FAILURE);
  }
  if (dup(fd) == -1) {
      perror("dup");
      exit(EXIT_FAILURE);
  }
  close(fd);
  execlp("ls", "ls", "-l", NULL);
  perror("execlp");
  exit(EXIT_FAILURE);
  ```

#### 使用 `dup2` 进行重定向
- **功能**：将一个文件描述符复制到指定的描述符，并自动关闭目标描述符。
- **步骤**：
  1. 打开目标文件。
  2. 使用 `dup2` 将目标文件描述符复制到标准输出或标准输入。
  3. 关闭原始文件描述符。
- **示例代码**：
  ```c
  int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  if (fd == -1) {
      perror("open");
      exit(EXIT_FAILURE);
  }
  if (dup2(fd, STDOUT_FILENO) == -1) {
      perror("dup2");
      exit(EXIT_FAILURE);
  }
  close(fd);
  execlp("ls", "ls", "-l", NULL);
  perror("execlp");
  exit(EXIT_FAILURE);
  ```

### 文件描述符的共享与重叠

#### 内核的数据结构
- **全局文件表**：记录所有进程共享的文件打开记录。
- **每个进程的文件描述符表**：记录进程使用的文件描述符及其对应的全局文件表项。

#### 示例说明
```c
int fd1 = open("toto", O_RDONLY);
int fd2 = open("toto", O_RDONLY);
dup2(fd1, 5);
read(fd1, buffer, 10); // 从偏移量25读取10字节
read(fd2, buffer, 33); // 从偏移量33读取33字节
read(5, buffer, 15);   // 从偏移量25读取15字节
```
- **解释**：
  - `fd1` 和 `5` 指向同一个全局文件表项，共享偏移量。
  - `fd2` 指向另一个全局文件表项，具有独立的偏移量。

### `fork` 后的文件描述符共享
- **特性**：
  - 父子进程共享打开的文件描述符，指向相同的全局文件表项。
  - 修改文件偏移量会影响所有共享该文件描述符的进程。

#### 示例说明
```c
int fd = open("toto", O_RDONLY);
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    read(fd, buffer, 10); // 修改偏移量
} else {
    // 父进程
    read(fd, buffer, 10); // 读取的偏移量已被子进程修改
}
```

---

### 总结
- **管道**是Unix系统中进程间通信的重要机制，支持数据的单向流动。
- **匿名管道**适用于有共同祖先的进程间通信，通过文件描述符共享实现。
- **命名管道（FIFO）**通过文件系统中的文件名实现任意进程间的通信，灵活性更高。
- **重定向**通过 `dup` 和 `dup2` 系统调用，将标准输入/输出重定向到管道或文件，实现复杂的命令行操作。
- **文件描述符共享**需要注意父子进程间的资源管理，防止资源泄漏和数据混淆。
- **最佳实践**：
  - 在 `fork` 前创建管道。
  - 在子进程中关闭不必要的文件描述符，进行重定向。
  - 在父进程中关闭不必要的文件描述符，等待子进程结束。

---
