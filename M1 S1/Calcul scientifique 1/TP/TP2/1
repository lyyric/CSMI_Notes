use std::f64::consts::PI;
use rsplot1d::plot1d;
use rsplot1d::plot;

// 计算傅里叶系数 c_n
fn compute_c(n: usize) -> f64 {
    if n == 0 {
        0.25 // c_0 = 1/4
    } else if n % 4 == 0 {
        // 当 n 是 4 的倍数时，sin(n*pi/2) = 0，因此 c_n = 0
        0.0
    } else if n % 2 == 0 {
        // n 为偶数但不是 4 的倍数
        let n_pi = n as f64 * PI;
        let term1 = (n_pi / 8.0).sin();
        let term2 = (n_pi / 2.0).sin();
        2.0 * term1 * term2 / n_pi
    } else {
        // n 为奇数，c_n = 0
        0.0
    }
}

// 计算 u_N(x, t)
fn u_N(x: f64, t: f64, N: usize) -> f64 {
    let mut sum = compute_c(0);
    for n in 1..=N {
        let c_n = compute_c(n);
        if c_n.abs() < 1e-10 {
            continue; // 跳过 c_n 非零的项
        }
        let exponent = - (n as f64 * PI).powi(2) * t;
        let term = c_n * exponent.exp() * (n as f64 * PI * x).cos();
        sum += term;
    }
    sum
}

fn main() {
    const N: usize = 50; // 截断级数的项数
    let t_values = [0.001, 0.01, 0.1, 1.0];
    let nx = 1000;
    let dx = 1.0 / nx as f64;
    let x_values: Vec<f64> = (0..=nx).map(|i| i as f64 * dx).collect();

    for &t in &t_values {
        let u_values: Vec<f64> = x_values.iter().map(|&x| u_N(x, t, N)).collect();
        // 使用 rsplot1d 绘制图像
        plot(&x_values, &u_values, &Vec::new()); // 第三个参数传递空的 Vec<f64>
    }
}
