### 堆排序及其复杂度分析

---

#### **一、堆的定义与基本性质**

##### **1. 二叉树的定义**

- **二叉树**是一种树，每个节点最多有两个子节点（左子节点和右子节点）。
- **树的高度**是从根节点到最深叶节点的距离。

##### **2. 堆的定义**

**堆**是一种特殊的二叉树，满足以下条件：
1. **完全二叉树**：树的每一层（除最后一层外）必须被完全填满，最后一层的节点从左到右填充。
2. **堆性质**：对于任意节点 $i$，有 $A[\text{父节点}(i)] \geq A[i]$。

---

#### **二、堆操作**

##### **1. “堆化”操作：调整单个节点使其符合堆性质**

当某个节点 $i$ 不满足堆性质时，我们需要调整它和它的子树，使整个子树重新成为一个堆。

**过程描述**：
- 比较节点 $i$ 的值与其两个子节点的值：
  - 如果 $A[i] < \max(A[2i], A[2i+1])$，则交换 $A[i]$ 和更大的子节点。
  - 递归调整交换后的子节点。

**伪代码**：
```plaintext
堆化(A, i):
    左子节点 = 2i
    右子节点 = 2i + 1
    最大值 = i
    如果 左子节点 <= 堆大小 且 A[左子节点] > A[最大值]:
        最大值 = 左子节点
    如果 右子节点 <= 堆大小 且 A[右子节点] > A[最大值]:
        最大值 = 右子节点
    如果 最大值 ≠ i:
        交换 A[i] 和 A[最大值]
        堆化(A, 最大值)
```

##### **2. 建堆：将无序数组调整为一个堆**

**方法**：从最后一个非叶节点开始，依次向上进行堆化操作，直到根节点。

**伪代码**：
```plaintext
建堆(A, n):
    对 i 从 ⌊n/2⌋ 到 1:
        堆化(A, i)
```

---

#### **三、堆排序**

##### **算法描述**

堆排序分两步：
1. **建堆**：将数组调整为一个堆。
2. **逐步排序**：
   - 将堆顶（最大值）与数组最后一个元素交换；
   - 缩小堆的范围（即从堆中移除最大值）；
   - 对新的堆顶进行堆化操作。

**伪代码**：
```plaintext
堆排序(A, n):
    建堆(A, n)
    对 i 从 n 到 2:
        交换 A[1] 和 A[i]
        堆大小 ← 堆大小 - 1
        堆化(A, 1)
```

---

#### **四、复杂度分析**

##### **1. 堆化的复杂度**

堆化操作的时间复杂度与子树的高度成正比：
$$
\text{堆化复杂度} = O(\text{子树高度})。
$$

对于一个大小为 $n$ 的堆，最大高度为 $\lfloor \log_2 n \rfloor$。

##### **2. 建堆的复杂度**

建堆时，从最后一个非叶节点（高度为 1）到根节点（高度为 $\log_2 n$），逐步进行堆化操作。

对于完全二叉树：
- 高度为 $h$ 的节点数为 $2^{h-1}$。
- 堆化的总成本为：
$$
\sum_{h=1}^{\lfloor \log_2 n \rfloor} \text{节点数} \times \text{堆化复杂度}
= \sum_{h=1}^{\lfloor \log_2 n \rfloor} 2^{h-1} \cdot h
$$

展开求和可得：
$$
\text{建堆复杂度} = O(n)。
$$

##### **3. 堆排序的复杂度**

排序过程中，每次交换和堆化的成本为 $O(\log n)$。总共有 $n-1$ 次交换和堆化操作，因此：
$$
\text{堆排序复杂度} = O(n \log n)。
$$

---

#### **五、堆排序与其他排序算法的比较**

| **排序算法**    | **最优复杂度** | **平均复杂度** | **最坏复杂度** | **备注**                        |
|------------------|----------------|----------------|----------------|---------------------------------|
| 冒泡排序         | $O(n^2)$    | $O(n^2)$    | $O(n^2)$    | 简单但效率较低。                |
| 快速排序         | $O(n \log n)$| $O(n \log n)$| $O(n^2)$    | 不稳定，最坏情况需要优化。       |
| 归并排序         | $O(n \log n)$| $O(n \log n)$| $O(n \log n)$| 稳定，适合大规模数据。          |
| **堆排序**       | $O(n \log n)$| $O(n \log n)$| $O(n \log n)$| 不稳定，但不需要额外存储空间。  |

堆排序的特点是**时间复杂度稳定在 $O(n \log n)$**，且对存储空间要求低，非常适合处理**内存有限的场景**。