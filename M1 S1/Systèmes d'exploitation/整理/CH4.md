# 进程管理

Pierre David  
pda@unistra.fr  
斯特拉斯堡大学  
2024 – 2025

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 使用许可

© Pierre David  
可在：https://gitlab.com/pdagog/ens 获取

本课程幻灯片遵循 “知识共享 署名 - 非商业性使用 4.0 国际” 许可协议。

要查看该许可协议的副本，请访问：
https://creativecommons.org/licenses/by-nc/4.0/

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 高层次定义进程

高级定义：

- 进程是一个正在执行的程序实例。

但并非任何执行都是一个进程：

- 当我执行 `ls /tmp` 时，该进程对应于执行程序 `ls`，数据为 `/tmp`。
- 如果其他人同时执行 `ls /tmp`，即使是相同的程序和数据，也不是同一次执行。
  - 这不是同一个进程。
  - 即使“其他人”是我自己。

---

## 进程的属性

一个进程具有以下属性：

- 状态（就绪运行、等待等）
- 进程标识符（pid）
- 父进程标识符（ppid）
- 所有者用户ID（uid），组ID（gid）
- 打开的文件
- 当前目录
- 控制终端
- 内存位置
- CPU 时间消耗
- 等等

---

## 低层次定义进程

低级定义：

一个进程由以下内容描述：

- 用于程序和数据的内存空间
- 属性
- 硬件上下文
  - 处理器寄存器
  - 地址转换（即可用的内存部分）

（参见 [task_struct](https://www.tldp.org/LDP/tlk/ds/ds.html)）

每当：

- 一个进程被从处理器中移除
  - 其上下文被保存（内存空间、处理器寄存器等）
- 一个进程被调度到处理器上
  - 其上下文被恢复

---

## 进程的内存空间

进程的内存空间分为三个区域：

```
0
|
|
|
|    "text" 段
|
|-------------------
|    "data" 段
|-------------------
|    "stack" 段
|
|
|
|
fff...fff
```

- **"text" 段**
  - 程序（编译后的代码）
  - 地址 0 未使用：为什么？
- **"data" 段**
  - 全局变量（加上静态局部变量）
  - 堆（通过 `malloc` 分配的内存）
  - 显式扩展（通过 `malloc`）
- **"stack" 段**：执行栈
  - 局部变量
  - 函数参数
  - 返回地址
  - 隐式扩展（使用栈）
- **其他可添加的区域**
  - 共享库
  - 进程间共享内存
  - ⇒ 参见操作系统架构课程

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 身份

```c
pid_t getpid(void);
pid_t getppid(void);

uid_t getuid(void);
gid_t getgid(void);
```

- 简单的系统调用...
- 不会返回 -1（无错误可能）
- 示例：

```c
pid_t pid, ppid;
uid_t uid;
gid_t gid;

pid = getpid();
printf("我是进程 %jd\n", (intmax_t) pid);

ppid = getppid();
printf("我的父进程是 %jd\n", (intmax_t) ppid);

uid = getuid();
printf("我的用户ID是 %ju\n", (intmax_t) uid);

gid = getgid();
printf("我的组ID是 %ju\n", (intmax_t) gid);
```

---

## 身份

```c
int setuid(uid_t uid);
int setgid(gid_t gid);
```

- 仅限于管理员（uid = 0）的系统调用
- 在系统登录时使用：
  - `/bin/login`、`sshd` 或 X-Window 等效程序
  - 由进程号为 1 的进程或其子进程启动

---

## 身份

系统登录的算法：

1. 请求用户名和密码
2. 在 `/etc/passwd` 中查找对应的条目
   - 条目格式：
     ```
     用户名:盐+加密密码:uid:gid:姓名:主目录:shell
     ```
   - 盐和加密密码放在一个单独的文件中（在 Linux 上为 `/etc/shadow`）
3. 使用条目中的“盐”加密密码
4. 将加密后的密码与条目中的密码进行比较
5. 如果匹配
   - 生成一个新进程
   - 在新进程中执行 `setuid(uid)` / `setgid(gid)`
   - 启动 shell（或“窗口管理器”）

---

## 文件创建掩码

```c
mode_t umask(mode_t mask);
```

- 文件创建时（`open(... O_CREAT...)`、`mkdir` 或 `mknod`）
- 创建的文件权限 = `mode & ~umask`

示例：

```
mode = 0124
umask = 0643
~umask = 0134
permissions = mode & ~umask = 0124 & 0134 = 0104
```

- 建议：在程序中使用权限 `0666` 或 `0777`
  - 程序是通用的
  - 让用户管理自己的隐私级别
  - Shell 中的 `umask` 命令
- 除非有特定的安全限制
- `umask` 返回旧的掩码（修改前）

---

## 当前目录

```c
int chdir(const char *path);
```

- 修改进程的当前目录
- 提示：当前目录是进程的一个属性
  - 在一个进程中更改不会影响其他进程
- 没有系统调用来获取当前目录的名称
  - 这是一个库函数
- 获取当前工作目录：

```c
char *getcwd(char *buf, size_t max);
```

- 它是如何工作的？

---

## 当前根目录

```c
int chroot(const char *path);
```

- 修改进程的当前根目录

示例：

- 假设文件系统结构如下：

```
/
├── etc
├── data
│   └── fichier
├── bin
├── usr
├── etc
├── tmp
└── un
    └── rep
```

- 执行 `chroot("/un/rep")` 后：
  - 当前根目录变为 `/un/rep`
  - 该文件 `fichier` 现在位于 `/data/fichier`
  - 该目录 `/un/rep` 现在作为根目录 `/`
  - 文件 `/bin/pwd` 现在变为 `/bin/pwd`（相对于新根目录）

- 无法绕过：
  - 在新根目录中，“..” 仍然指向同一位置
  - 只能在文件系统树中向下移动
- 仅管理员可用
- 非 POSIX 标准的系统调用

---

## 当前根目录

`chroot` 是一种限制系统：

- 将环境限制在某些特定文件上
- 示例：特定应用程序的用户账户
- 示例：匿名 FTP 服务器
  - 提供文件分发的 FTP 服务，限制在文件系统的一部分
- `chroot`：现代“容器”系统的基础
  - Linux 上的 LXC，FreeBSD 上的 Jails
- 补充其他限制系统
  - 受限的进程可见性
  - 受限的网络连接可见性
  - 等等
- 实现低成本的“虚拟”机器

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 进程的创建

```c
pid_t fork(void);
```

创建一个进程 ⇔ 复制进程

- `fork` 系统调用 = 进程的复印机
- 进程 = 内存 + 属性 + 硬件上下文
- 几乎所有内容都被复制
  - 内存被复制 ⇒ 变量被复制
  - 处理器寄存器也被复制：每个程序将独立运行（程序计数器 PC）
- 复制 ⇒ 继承父进程的信息
  - 当前目录、打开的文件等
- 除了一些属性：`pid`、`ppid`、CPU 时间等

---

## 进程的创建

示例：

```c
pid_t v;
int x = 5;
v = fork();
x = getpid();
printf("%d\n", x);
```

- **在 `fork()` 之前**

  - 进程有自己的 PC、寄存器和内存

- **`fork`：进程的复制**

  - 进程被复制，生成一个子进程

- **在 `fork()` 之后**

  - 两个进程独立运行，各自有自己的 `pid` 和 `ppid`
  - 父进程 `pid` 为 1234，`ppid` 为 1123
  - 子进程 `pid` 为 1567，`ppid` 为 1234
  - 变量 `x` 和 `v` 在两个进程中独立存在

---

## 进程的创建

- `fork` 的特殊之处：
  - 一个调用，两个返回
  - 因为 `fork` 复制了进程，对于第二个进程来说，就像它自己调用了 `fork`
- `fork` 的返回值：
  - 如果出错，返回 -1
  - 在子进程中返回 0
  - 在父进程中返回子进程的 `pid`（>0）
- 非确定性：
  - 在 `fork` 之后，不知道是父进程还是子进程首先运行
    - 取决于进程调度
  - 这不是问题：进程独立运行

---

## 进程的创建

记忆 `fork` 返回值的方法：

- 每个进程都知道其父进程
  - 属性 `ppid`，通过 `getppid` 获取
  - 信息容易获取
  - ⇒ 不需要通过 `fork` 获取父进程的 `pid`
- 没有简单的方法获取子进程的 `pid`
  - 可能有多个子进程，返回哪个？
  - 没有属性，没有系统调用
  - ⇒ 获取子进程的 `pid` 的唯一方法是 `fork`
- `fork` 返回子进程的 `pid` 给父进程
- `fork` 返回 0 给子进程

---

## 进程的创建

在实践中，`fork` 只有在区分父进程和子进程的操作时才有意义

因此，需要测试返回值：

- 如果是 -1 ⇒ 错误
- 如果是 0 ⇒ 当前是子进程
- 如果既不是 -1 也不是 0 ⇒ 当前是父进程

---

## 进程的创建

使用 `fork` 的建议：

- 使用 `switch` 处理 3 种情况：-1、0 和 `default`
  - 确保不遗漏任何情况
- 在 `case 0`（子进程）中调用一个子进程函数，并以 `exit` 结束
  - 隔离子进程的代码
- 放置一个“安全带”，防止子进程执行父进程的代码

---

## 进程的创建

示例：

```c
pid_t v;
switch (v = fork()) {
  case -1: // 错误：不要忘记这种情况
    perror("fork");
  case 0: // 子进程
    child_function(); // 隔离子进程
    exit(0); // 安全带
  default: // 父进程继续
    // 父进程的代码
    ...
}
```

---

## 进程的终止

```c
void exit(int code);
```

- 终止当前进程
- 无返回
- 因此不存在错误返回 -1 的情况
- 几乎所有资源都被释放
  - 内存、CPU 等
- 对于僵尸进程的特殊处理（稍后讨论）

---

## 进程的终止

`exit` 的参数：

- `code ∈ [0..255]`
- 如果在程序中看到 `exit(-1)`，说明作者没有理解系统课程...
- 值 0：表示成功
  - Shell 使用的约定
- 如果父进程不是 Shell，可以使用其他约定
- POSIX 常量：`EXIT_SUCCESS` 和 `EXIT_FAILURE`
- 注意：POSIX 常量 `EXIT_FAILURE` 不适用
  - （对于 Shell，任何不等于 `EXIT_SUCCESS` 的值都表示失败）

---

## 进程的终止

实际上，`exit` 是一个库函数

- 清空由 `fopen` 打开的文件的缓冲区
- 调用由 `atexit` 注册的函数
- 真正的系统调用是 `_exit`
  - 通常不直接调用

---

## 进程的终止

```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```

- 等待某个子进程的终止
- `wait` 等待任何子进程
  - 如果有已终止的子进程，则不等待
  - 如果没有子进程，返回 -1
  - 如果至少有一个子进程，则等待
  - 如果等待被信号中断，返回 -1
- `waitpid` 等待特定的进程（详见手册）
- 终止可能有多种原因：
  - 子进程调用 `exit`
  - 子进程收到信号
    - 如 `CTRL-C`、段错误等
  - 也可能是非终止原因
    - 进程在调试器中达到断点

---

## 进程的终止

`status` 指向的整数：终止的原因

- 多个信息的编码示例：

  - 进程在跟踪模式下停止：
    - 返回码高位为 `0177`，低位为信号编号
  - 进程通过 `exit` 终止：
    - 返回码高位为 `0`，低位为 `exit` 参数的 8 位值
  - 进程被信号终止：
    - 返回码高位为 `0`，低位为信号编号（如果有 core dump，加上 `0200`）
  - `wait` 被信号中断：
    - 返回值为 `-1`

- 注意：编码未被 POSIX 标准化
- POSIX 简化了工作：常用的宏

  - 通过 `exit` 终止？`WIFEXITED()`
    - 如果是，获取返回值：`WEXITSTATUS()`
  - 被信号终止？`WIFSIGNALED()`
    - 如果是，获取信号编号：`WTERMSIG()`

---

## 进程的终止

示例：

```c
pid_t v;
int status;

switch (v = fork()) {
  case -1:
    perror("fork");
  case 0: // 子进程
    child_function();
    exit(0);
  default: // 父进程
    if (wait(&status) == -1)
      perror("wait");
    if (WIFEXITED(status))
      printf("exit(%d)\n", WEXITSTATUS(status));
    else if (WIFSIGNALED(status))
      printf("signal %d\n", WTERMSIG(status));
    else
      printf("其他原因\n");
}
```

---

## 特殊情况——僵尸进程

**定义：**

僵尸进程是已终止的进程，其父进程尚未通过 `wait` 获取其终止信息

- 僵尸进程“几乎”已终止
  - 其几乎所有资源都已释放
  - 但进程描述符仍保留
    - 它包含终止的原因
    - 以及资源使用的摘要
  - 没有时间限制
  - 可以通过 `ps` 命令查看
- 当父进程调用 `wait`：
  - 它收集必要的信息
  - 进程描述符被释放
  - 进程完全从系统中消失

---

## 特殊情况——孤儿进程

当一个进程的父进程终止时，会发生什么？

- 父进程终止 ⇒ 变为僵尸进程
- 子进程被“重新归属”（`ppid` 变为 1）
- 进程 1 是特殊的
  - 永不终止
  - （重新）启动系统程序

示例：

```c
list = read_files("/etc/init/");
start_all_tasks(list);
for (;;) {
  pid = wait(&status);
  ps = find_task(pid, list);
  if (ps != NULL)
    restart_task(ps);
}
```

- 子进程立即被重新归属
- 在内核中不存在孤儿状态

注意：在某些 Linux 版本中，父进程成为用户会话的管理器（`systemd`），而不是进程 1

---

## 进程的状态

进程的状态：

- 创建
- 在处理器上运行
- 等待资源
- 准备运行
- 资源请求
- 获得资源
- 当选
- 时间片到期
- 终止
- 僵尸

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 文件的执行

```c
int execl(const char *path, const char *arg, ...);
int execv(const char *path, char *const argv[]);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execlp(const char *file, const char *arg, ...);
int execvp(const char *file, char *const argv[]);
```

- `exec*` 系统调用：将当前进程的程序替换为新程序及其参数
- 进程的上下文几乎保持不变
  - 未修改的属性：`pid`、`ppid`、`uid`（除非有特殊情况）、`umask`、当前目录、CPU 时间消耗等
  - 修改的属性：可执行文件的引用、打开的文件（除非有特殊情况，特别是描述符 0、1 和 2）等
- 内存空间被新程序初始化
  - `text` 段、`data` 段和 `stack` 段
- 返回值 = -1（始终如此）
  - 如果返回，则新程序未加载 ⇒ 出错

---

## 文件的执行

示例：

```c
int main(int argc, char *argv[]) {
  execl("/bin/echo", "echo", "a", "b", NULL);
  perror("exec");
  printf("bonjour\n");
}
```

- 程序尝试执行 `/bin/echo`
- 如果 `exec` 成功，则不会返回，也不会执行后续的 `printf("bonjour\n");`
- 如果 `exec` 失败，则执行 `perror("exec");` 并输出错误信息

---

## 文件的执行——示例

由于 `exec*` 不返回，通常与 `fork` 结合使用

```c
switch (fork()) {
  case -1:
    perror("fork");
  case 0: // 子进程
    execl("/bin/echo", "echo", "a", NULL);
    perror("execl");
  default: // 父进程
    if (wait(&status) == -1)
      perror("wait");
    if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
      printf("执行成功\n");
    else
      printf("执行失败\n");
}
```

---

## 文件的执行——示例

另一个示例：Shell 的（简化）算法

1. 读取一行命令
2. 将命令行解析为元素
3. 如果 `elements[0]` 是内置命令
   - 执行对应的函数
   - 返回步骤 1
4. 在 `PATH` 中查找文件 `elements[0]`
5. 如果未找到，输出错误并返回步骤 1
6. `fork` 创建子进程
   - 在子进程中执行 `exec(elements)`
7. 如果 `elements[end]` 不等于 `&`
   - 等待子进程结束
8. 返回步骤 1

---

## 文件的执行——环境

除了参数，`exec*` 还传递环境变量：

- `HOME=/home/toto`
- `PATH=/bin:/usr/bin:...`
- `TERM=xterm`
- ...

- 使用 `extern char **environ` 访问环境
- 使用库函数 `getenv` 获取环境变量
- 环境由 Shell 修改
- 所有由 Shell 启动的进程继承环境
- 提醒：在 Shell 中使用 `export` 导出环境变量

---

## 文件的执行

`exec*` 有六种形式：

- 参数的传递方式：
  - `execl` 以列表形式传递参数：`execl(..., "echo", "a", "b", NULL);`
  - `execv` 以数组形式传递参数：`execv(..., argv);`
- 是否在 `PATH` 中搜索：
  - `exec[vl]` 不搜索：`execv("/bin/echo", argv);`
  - `exec[vl]p` 搜索：`execvp("echo", argv);`
- 环境的传递方式：
  - `exec[vl]` 隐式使用当前环境：`execv("/bin/echo", argv);`
  - `exec[vl]e` 显式传递环境：`execve("echo", argv, envp);`

这六种形式中只有一种是系统调用（哪一种？）

⇒ 其他都是库函数

---

## 魔数

`exec*` 可以执行多种类型的文件：

- **二进制文件**（已编译）
  - 可能有多种格式
  - 格式的演变，兼容旧版本
  - 在 FreeBSD 上：Linux 兼容模式
- **解释型文件**
  - 不能直接执行的文件
  - 借助解释器执行
    - Shell、Awk、Perl、Tcl、Ruby、Python 等

文件开头存在一个“魔数”：

- 二进制文件：`0x7f` `'E'` `'L'` `'F'`（Linux 下的 ELF 格式）
- 解释型文件：`'#'` `'!'`（后跟解释器的路径）

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 执行权限

```
sh
cat secret.txt
用户：tata
fork
exec
文件：secret.txt
所有者：toto
权限：rw- --- ---
open("secret.txt", ...)
errno = EPERM
```

- `fork`：子进程继承用户 ID（`tata` 的 UID）
- `exec`：不更改用户 ID（仍为 `tata` 的 UID）
- 用户 `toto` 的文件 `secret.txt` 无法被属于 `tata` 的进程打开
- ⇒ 权限系统正常工作！

---

## 执行权限——权限提升

在某些情况下，需要以更高的权限执行程序：

- 用户更改密码 ⇒ 需要在 `/etc/passwd` 中写入新的加密密码
  - `/etc/passwd` 无法由普通用户修改
  - 示例：
    ```
    $ ls -l /etc/passwd
    -rw-r--r-- 1 root 12345 Jan 1 1970 /etc/passwd
    ```
- 用户插入相机的 SD 卡 ⇒ 文件系统需要被“挂载”
  - 挂载操作（`mount` 系统调用）仅限管理员使用
- 用户希望使用 `ping` 命令
  - `ping` 访问底层网络，需要管理员权限

---

## 执行权限——权限提升

回顾文件权限位：

```
权限位编号：0 1 2 3 4 5 6 7 8 9 10 11
权限位：
所有者  组   其他
r w x  r w x  r w x
s s
t
```

- `s` 位表示 `set-user-id-on-exec` 位（SUID 位）
- `s` 位表示 `set-group-id-on-exec` 位（SGID 位）
- `t` 位表示 `sticky` 位

---

## 执行权限——`set-user-id-on-exec` 位

- 当执行 `exec` 时，如果 SUID 位为 1，则进程的有效用户 ID 变为文件所有者的用户 ID
  - 换句话说：以文件所有者的权限执行程序，而不是当前用户的权限
- 示例：
  - 程序 `/bin/passwd` 属于 `root` 用户
  - 其权限中，SUID 位为 1
  - ⇒ 进程可以修改 `/etc/passwd` 文件
  - ⇒ 普通用户可以更改自己的密码！

---

## 执行权限——`set-user-id-on-exec` 位

- **问题 1**：`/bin/passwd` 需要知道是哪个用户在更改密码
  - ⇒ 引入两个不同的用户 ID 概念：
    - **实际用户 ID**：终端后的人，`uid_t getuid(void);`
    - **有效用户 ID**：用于权限检查的用户 ID，`uid_t geteuid(void);`

---

## 执行权限——`set-user-id-on-exec` 位

- **问题 2**：对于某些操作，需要使用实际用户 ID 而非有效用户 ID
  - 示例：创建文件 ⇒ 文件所有者 = 有效用户 ID
  - 有时需要临时切换到实际用户身份
    - 示例：以正确的身份创建文件
  - 因此引入第三个概念：**保存的用户 ID**
    - 保存的用户 ID 允许在更改有效用户 ID 时保存它（使用 `int seteuid(uid_t euid);`）
    - 允许切换到实际用户 ID，然后再切换回特权身份

---

## 执行权限——`set-user-id-on-exec` 位

另一个示例：

- 包含游戏“xyz”最高分的文件 `scores`：
  ```
  pierre 7540
  paul   6920
  ```
- 如果用户 `jacques` 获得了 8627 分，他需要能够写入该文件
- 如果文件对所有人可写，恶意用户可能会修改文件，写入虚假的分数
- **解决方案：**
  - 创建一个虚拟用户（例如 `superxyz`）
  - 文件 `scores` 属于 `superxyz`，权限为 `rw-r--r--`
  - 可执行文件 `xyz` 属于 `superxyz`，并设置了 SUID 位
  - **注意**：可执行文件中的编程错误可能导致安全问题...

---

## 执行权限——`set-group-id-on-exec` 位

相同的原则适用于组：

- `set-group-id-on-exec` 位（SGID 位）
- 有三个组 ID：
  - **实际组 ID**
  - **有效组 ID**
  - **保存的组 ID**

**注意：**

- `ls` 命令会显示这些位
- 示例：

  ```
  $ ls -l /usr/bin/passwd /usr/bin/crontab
  -rwsr-xr-x 1 root root    12345 Jan 1 1970 /usr/bin/passwd
  -rwxr-sr-x 1 root crontab 23456 Jan 1 1970 /usr/bin/crontab
  ```

---

## 执行权限——权限提升

SUID 和 SGID 位：改变权限级别

- 大多数情况下：提升权限级别
  - 示例：`sudo` 命令
- 也可能降低权限级别
- **这些可能带来安全问题**
  - 提升权限 ⇒ 需要注意编程！
    - 仔细检查权限
    - 防止安全漏洞
      - 如缓冲区溢出、系统调用的错误处理等
  - 限制带有这些位的可执行文件数量
- 示例：在一台 Linux 系统（Ubuntu 23.04）上：
  - 带有 SUID 位的文件：27 个
  - 带有 SGID 位的文件：18 个
- 可以使用以下命令查找：

  ```
  find / -type f -perm -04000
  ```

---

## 目录

- 引言
- 属性管理
- 进程的创建
- 文件的执行
- 执行权限
- 重定向和文件打开的共享

---

## 重定向

Shell 允许进行重定向：

- 示例：`$ wc -l < input > output 2> errors`
- 回顾：三个默认的文件描述符：
  - `0`：标准输入
  - `1`：标准输出
  - `2`：标准错误输出
- 重定向 = 修改文件描述符 `0`、`1` 或 `2`
- **在子进程中完成**（而不是在父进程中），在执行 `exec` 之前

---

## 重定向

示例：Shell 重定向标准输出

1. 读取一行命令
2. 将命令解析为元素
3. 如果 `elements[0]` 是内置命令
   - 执行对应的函数
   - 返回步骤 1
4. 在 `PATH` 中查找文件 `elements[0]`
5. 如果未找到，输出错误并返回步骤 1
6. `fork` 创建子进程
   - `close(1);`
   - `open("toto", O_WRONLY | O_CREAT...);` ⇒ 返回文件描述符 `1`
   - 执行 `exec(elements);`
7. 如果 `elements[end]` 不等于 `&`
   - 等待子进程结束
8. 返回步骤 1

---

## 重定向

修改文件描述符的方法有多种：

1. 关闭一个描述符，然后打开一个新文件
   - 如上例所示
   - 由于 `open` 总是返回最小的可用描述符，因此新的文件描述符将是已关闭的那个

---

## 重定向

修改文件描述符的方法有多种：

2. 使用系统调用 `int dup(int fd);`：复制一个文件打开

示例：

```c
fd = open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666);
if (fd == -1)
  perror("open");
if (close(1) == -1)
  perror("close");
if (dup(fd) == -1)
  perror("dup");
if (close(fd) == -1)
  perror("close");
execv(path, argv);
perror("execv");
```

- **优点**：在父进程中（`fork` 之前）打开文件，避免在发生错误时创建不必要的进程

---

## 重定向

修改文件描述符的方法有多种：

3. 使用系统调用 `int dup2(int oldfd, int newfd);`

示例：

```c
fd = open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666);
if (fd == -1)
  perror("open");
if (dup2(fd, 1) == -1)
  perror("dup2");
if (close(fd) == -1)
  perror("close");
execv(path, argv);
perror("execv");
```

- **优点 1**：`dup2` 在必要时会关闭目标描述符
- **优点 2**：方便指定新的描述符

---

## 文件打开的共享——`dup`/`dup2`

内核的数据结构：

- 一个全局的文件打开表
- 每个进程有一个文件描述符表

示例：

```c
fd1 = open("toto", O_RDONLY);
fd2 = open("toto", O_RDONLY);
dup2(fd1, 5);
read(fd1, ..., 10);
read(fd2, ..., 33);
read(5, ..., 15);
```

- 文件 `toto`
- 文件打开表：
  - 引用计数
  - 读/写模式
  - 偏移量
  - 文件

- 文件描述符表：
  - 每个进程都有自己的文件描述符表
  - `fd1` 和 `5` 共享同一个文件打开，偏移量共享
  - `fd2` 有自己的文件打开和偏移量

---

## 文件打开的共享——`dup`/`dup2`

在文件中读取数据：

- `fd1` 和 `5` 共享偏移量
- `fd2` 有自己的偏移量

读取操作：

- `read(fd1, ..., 10);` 读取 10 字节
- `read(fd2, ..., 33);` 读取 33 字节
- `read(5, ..., 15);` 读取 15 字节

结果：

- `fd1` 和 `5` 的偏移量为 25（10 + 15）
- `fd2` 的偏移量为 33

---

## 文件打开的共享——`fork`

如果在文件打开之后调用 `fork`，会发生什么？

- 子进程会复制父进程的文件描述符表
- 父子进程共享相同的文件打开
- 因此，文件打开的偏移量在父子进程之间共享

---

## 文件打开的共享——`fork`

示意图：

```
文件打开表
├── 文件打开 1
│   ├── 引用计数：2
│   ├── 偏移量：...
│   └── ...
└── ...

父进程的文件描述符表
├── 文件描述符 0
├── 文件描述符 1
├── 文件描述符 2
└── 文件描述符 3 -> 文件打开 1

子进程的文件描述符表（由 `fork` 复制）
├── 文件描述符 0
├── 文件描述符 1
├── 文件描述符 2
└── 文件描述符 3 -> 文件打开 1
```

- 父子进程共享文件打开
- 通过共享的文件描述符访问相同的文件打开

---