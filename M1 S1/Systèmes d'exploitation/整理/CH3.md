目录

1. 引言
2. 设备驱动程序
3. `/dev` 目录

---

## 引言

在 Unix 系统中，设备像文件一样被访问。

> **谚语：**“万物皆文件”

### 示例

**在打印机上打印：**

```c
int fd;
fd = open("/dev/lpr", O_WRONLY);
write(fd, "ligne a imprimer\r\n", 18);
close(fd);
```

**读取硬盘内容：**

```c
uint8_t bloc[512];
int fd;
fd = open("/dev/disk2", O_RDONLY);
read(fd, bloc, sizeof bloc);
close(fd);
```

**魔法在哪里？**

### 新的文件类型

两种新的特殊文件类型（设备）：

- **字符设备**
  - 在 `stat` 中使用：`S_IFCHR` 和 `S_ISCHR()`
  - 本应称为：“原始”模式
  - 通过 `read` 或 `write` 传递的任何字节序列都会立即传输
  - 几乎所有设备都是字符设备
  - 设备由一对 `<主设备号, 次设备号>` 标识
- **块设备**
  - 在 `stat` 中使用：`S_IFBLK` 和 `S_ISBLK()`
  - 本应称为：“缓冲”模式
  - 通过 `read` 或 `write` 传递的任何字节序列会被缓冲，然后传输到设备
  - 主要是硬盘
  - 设备也由一对 `<主设备号, 次设备号>` 标识

文件传统上位于 `/dev` 目录下。

### 设备号

设备由一对 `<主设备号, 次设备号>` 标识：

- **主设备号：**驱动程序编号（原始或缓冲）
- **次设备号：**由该驱动程序管理的设备编号（可能还包含其他信息）

**示例：**Linux 中的磁盘驱动程序“sd”：

- 主设备号：`8`
- 次设备号：磁盘地址（位≥4）+ 分区号（位0..3）
- 数据类型 `dev_t`：包含主设备号和次设备号

### 创建设备文件

```c
int mknod(const char *path, mode_t mode, dev_t dev);
```

- **作用：**创建一个设备文件
- **限制：**仅限系统管理员使用
- **参数：**
  - `mode`：类似于 `st_mode`（类型和权限）
- **注意：**
  - 不被 POSIX 支持的用法
  - 已过时，设备现在自动创建

### `stat` 函数的使用

对于设备文件：

- 使用 `S_ISBLK()` 或 `S_ISCHR()` 测试 `st_mode` 字段
- `st_rdev` 字段表示设备号

对于所有文件：

- 常规文件、目录、符号链接、设备等
- 文件所在磁盘的设备号在 `st_dev` 字段

---

## 设备驱动程序

### 设备驱动程序的概念

- **定义：**一组添加到内核中的已编译函数
- **引用：**函数在内核的驱动程序表中被引用
- **类型：**根据驱动程序类型的不同，函数也不同

#### 字符设备驱动程序

- 函数：`open`，`close`，`read`，`write`，`ioctl`，中断处理

#### 块设备驱动程序

- 函数：`open`，`close`，`strategy`，中断处理

### 请求处理流程

```c
ssize_t lp_write(int dev, ...) {
    // 驱动程序实现
}

// 驱动程序被添加到内核中
// 用户程序调用驱动程序

int fd = open("/dev/lp", ...);
write(fd, "ligne a imprimer", 18);
...

// 内核调用驱动程序的写函数
(*cdevsw[major(dev)].write)(minor(dev), ...);

ssize_t write(...) {
    // 检查
}
if (type == S_IFCHR) {
    // ...
}
```

### 字符设备的接口

- **基本函数：**`open`，`close`，`read`，`write`
- **中断处理：**在设备处理结束时被调用
- **`ioctl` 函数：**
  - 原型：`int ioctl(int fd, int request, ...);`
  - 用于执行不符合 `read`/`write` 模型的特定操作
  - **示例：**
    - 查询打印机状态（打印中、缺纸等）
    - 弹出介质（磁带、CD、DVD 等）
    - 改变串行连接的速度

### 终端设备的特殊示例

**特性：**

- 通过串行连接
- 参数：速度、数据位数、校验位
- 挂断调制解调器等

**自有特性：**

- 删除、停止、挂起、文件结束字符
- 行缓冲或立即发送字符
- 行数、列数等

**使用 `stty` 命令更改参数（调用 `ioctl`）**

### 终端的控制

- 驱动程序负责将字节传输到终端
- 一些程序（如 `zsh`、`vi`、`more`）需要：
  - 清除屏幕
  - 定位光标
  - 识别功能键等
- 不同终端有不同的控制序列
  - **示例：**定位光标到第 `X` 行，第 `Y` 列
    - DEC VT100：`ESC [ X ; Y f`
    - HP 2645：`ESC & a Y c X Y`
- 使用 `termcap` 或 `terminfo` 数据库
  - 环境变量 `TERM` 指定终端类型
  - 程序需要使用该数据库
- **注意：**这些不是驱动程序的职责

### 设备协议管理

- 驱动程序仅负责传输字节
- 应用程序需要管理设备的协议
  - **示例：**
    - 不同鼠标有不同协议，只有 X-Window 服务器需要处理
    - 每台打印机有自己的控制语言，程序需要适配不同打印机

### 块设备的接口

- **函数：**`open`，`close`（在挂载/卸载文件系统时调用）
- **中断处理：**与字符设备类似
- **`strategy` 函数：**
  - 读取内存中缓冲区缓存的块
  - 将修改后的块写入磁盘
  - 实现优化（如电梯算法）

**注意：**大多数块设备驱动程序也有对应的字符设备驱动程序（用于 `ioctl`）

### 伪设备

驱动程序可以提供无需真实设备的服务，通过 `read` 或 `write` 访问。

**示例：**

- `/dev/null`：空设备（丢弃所有写入的数据）
- `/dev/mem`：计算机的全部内存
- `/dev/random`：随机数生成器

### 伪终端

- **需求：**模拟终端和串行连接
- **组成：**一对伪设备——主设备和从设备
  - 由同一驱动程序管理
- **应用：**
  - `ssh` 服务器管理主设备
  - 会话程序访问从设备，模拟真实终端

**工作原理：**

- `ssh` 服务器打开设备对
- 数据在主设备和从设备之间传输
- 终端参数的改变通过 `ioctl` 传递给 `ssh` 服务器

**其他用途：**

- 图形环境中的终端窗口
- 会话记录（`script` 命令）
- 多重会话管理（`screen`，`tmux`）

### 设备管理的演变

- **硬件复杂度增加**
  - 管理不同级别的总线（PCI、USB、SATA 等）
  - 驱动程序之间的代码共享（如磁盘驱动）
- **设备的动态性**
  - 支持热插拔
  - 自动识别设备（即插即用）
- **结果：**驱动程序的复杂性增加

---

## `/dev` 目录

### 历史背景

- **传统上，**`/dev` 目录由手动填充
  - 很少添加或删除设备
  - 使用 `mknod` 命令
  - 在 `/dev` 目录下有 `MAKEDEV` 脚本

### 动态设备管理

- **演变：**动态添加设备
  - 使用 `devfs` 文件系统
  - 自动创建和销毁特殊文件
  - 需要设备能够自我识别（即插即用）
- **附加程序：**处理例外情况
  - **示例：**
    - 创建 `/dev/cdrom` 链接到系统中的第三个 CD 驱动器
    - 在没有管理员权限的情况下连接相机

---

