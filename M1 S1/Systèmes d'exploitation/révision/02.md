## 文件管理

### 课程大纲
1. 文件访问
2. 系统原语与库函数
3. 文件属性
4. 目录
5. 链接

---

## 1. 文件访问

### 文件的基本概念
一个文件具有以下几个基本特征：
- **名称**：实际上可以有多个名称。
- **路径**：通过绝对路径或相对路径进行访问。
- **属性**：包括类型、所有者、群组、权限、大小、各种日期（如最后修改日期、最后访问日期）、数据在磁盘上的存储位置等。
- **文件类型**：主要有“常规文件”和“目录”，实际上还有其他类型（后续会详细介绍）。

### 文件结构
文件在Unix系统中被视为一个线性字节序列：
```
0 1 2 3 4 5 6 ... n-1
C o u c o u
```
- **Unix的创新**：早期系统中的文件有不同的类型（如文本文件、数据库文件等），而Unix统一为字节序列，这简化了内核设计。
- **结构由应用程序决定**：
  - **文本文件**：字符序列，以`\n`（ASCII 10）分隔。
  - **二进制可执行文件**：包含描述不同部分的头信息（代码、数据、调试信息等）。
  - **文档文件**：如LibreOffice文档，由相应的应用程序处理。
  - **其他类型**：根据具体应用程序的需求定义。

- **Magic Number**：文件开头的一些字节用于识别文件类型，例如：
  - `#!`（脚本文件）
  - `%PDF`（PDF文件）
  - `0xffd8`（JPEG图片）

### 示例命令
```bash
$ pwd
/home/pda

# 使用 file 命令猜测文件类型
> file ch2-file.tex
ch2-file.tex: LaTeX 2e document, Unicode text, UTF-8 text
> file ch2-file.pdf
ch2-file.pdf: PDF document, version 1.5

# 查看文件前10个字节的十六进制和字符
> od -t xCc -N 10 ch2-file.pdf
0000000 25 50 44 46 2d 31 2e 35 0a 25
% P D F - 1 . 5 \n %
```

### 文件名的意义
- 文件名对内核没有特殊含义，你可以任意命名文件，例如`executable.toto.titi.tata`或`textfile.toto.xls`。
- 某些应用程序依赖文件后缀名，例如C编译器假设源文件以`.c`结尾，但这并不是通用规则。

---

## 2. 系统原语与库函数

### 为什么有两套文件访问函数？
- **系统原语**：如 `open`, `close`, `read`, `write`, `lseek`，这些函数直接与操作系统内核交互，提供底层文件操作接口。
- **库函数**：如 `fopen`, `fclose`, `getc`, `putc`, `fread`, `fwrite`, `fseek` 等，这些函数基于系统原语，提供更高层次、更方便的接口，适合应用程序开发。

### 为什么会有两套功能相似的函数？
- **系统原语**提供对文件的底层控制，适用于需要高效、细粒度操作的场景。
- **库函数**通过封装系统原语，提供更易用的接口，适合大多数应用程序开发需求。
- **系统原语**更注重安全性和控制，**库函数**则更注重便捷性和编程效率。

### 示例对比

#### 使用系统原语
```c
int fd1, fd2;
char c;
ssize_t n;

fd1 = open("toto", O_RDONLY);
if (fd1 == -1)
    raler("open toto");
fd2 = open("titi", O_WRONLY | O_CREAT | O_TRUNC, 0666);
if (fd2 == -1)
    raler("open titi");
while ((n = read(fd1, &c, 1)) > 0)
    if (write(fd2, &c, 1) == -1)
        raler("write");
if (n == -1)
    raler("read");
if (close(fd1) == -1)
    raler("close toto");
if (close(fd2) == -1)
    raler("close titi");
```

#### 使用库函数
```c
FILE *fp1, *fp2;
int c;

fp1 = fopen("toto", "r");
if (fp1 == NULL)
    raler("fopen toto");
fp2 = fopen("titi", "w");
if (fp2 == NULL)
    raler("fopen titi");
while ((c = getc(fp1)) != EOF)
    if (putc(c, fp2) == EOF)
        raler("putc");
if (ferror(fp1))
    raler("getc");
if (fclose(fp1) == -1)
    raler("fclose toto");
if (fclose(fp2) == -1)
    raler("fclose titi");
```

### 区别与效率
- **系统原语**直接操作文件描述符，适合底层编程，提供更高的控制。
- **库函数**通过缓冲机制减少系统调用次数，提高效率，适合频繁的小量读写操作。
- **系统原语**每次读写都需要切换到内核模式，开销较大，适合大块数据操作。
- **库函数**通过缓冲区批量读写，减少系统调用次数，适合小块数据频繁读写。

### Buffering（缓冲）
- **库函数**在用户空间维护一个缓冲区，批量进行读写，减少系统调用次数，提高效率。
- **效果**：
  - 对于频繁的小量操作，库函数更高效。
  - 对于大块数据读写，系统原语更高效，因为库函数的缓冲机制会增加额外开销。

### 总结
- **系统原语**适用于需要高效、底层控制的场景。
- **库函数**适用于便捷的编程和频繁的小量操作。
- 理解两者的区别有助于在不同场景下选择合适的接口。

---

## 3. 文件属性

### 文件属性概述
每个文件都有一些关联的属性，包括：
- **类型**：如常规文件、目录、符号链接等。
- **所有者和群组**：文件的拥有者和所属群组。
- **权限**：读、写、执行权限。
- **大小**：文件大小（字节数）。
- **日期**：包括最后访问时间、最后修改数据时间、最后修改属性时间。
- **链接数**：指向该文件的硬链接数量。
- **设备号和文件号**：用于唯一标识文件。
- **数据在磁盘上的位置**：由内核管理，不对用户公开。

### 查看文件属性
#### 使用 `stat` 系统调用
```c
int stat(const char *path, struct stat *stbuf);
int fstat(int fd, struct stat *stbuf);
```
- **功能**：获取文件的所有属性，并存储在 `struct stat` 结构体中。
- **结构体 `stat` 包含**：
  - `st_mode`：文件类型和权限
  - `st_uid`：所有者用户ID
  - `st_gid`：群组ID
  - `st_size`：文件大小（字节）
  - `st_atime`：最后访问时间
  - `st_mtime`：数据最后修改时间
  - `st_ctime`：属性最后修改时间
  - 其他属性

### `st_mode` 的使用
- `st_mode` 包含文件类型和权限信息。
- **文件类型示例**：
  - 目录：`0x1000`
  - 常规文件：`0x2000`
- **权限获取**：
  - 获取权限：`stbuf.st_mode & 0777`
  - 获取类型：`stbuf.st_mode & 0xf000`
- **使用POSIX宏判断文件类型**：
  ```c
  if (S_ISDIR(stbuf.st_mode)) {
      // 是目录
  }
  if (S_ISREG(stbuf.st_mode)) {
      // 是常规文件
  }
  ```

### 检查权限
`stat` 系统调用仅提供权限信息，无法直接判断是否有权限访问，需要使用 `access` 系统调用：
```c
int access(const char *path, int mode);
```
- **mode 参数**：
  - `F_OK`：检查文件是否存在
  - `R_OK`：检查读权限
  - `W_OK`：检查写权限
  - `X_OK`：检查执行权限
- **返回值**：
  - 有权限：返回 `0`
  - 无权限：返回 `-1`

### 修改文件属性
- **修改权限**：
  ```c
  int chmod(const char *path, mode_t mode);
  int fchmod(int fd, mode_t mode);
  ```
- **修改所有者或群组**：
  ```c
  int chown(const char *path, uid_t uid, gid_t gid);
  int fchown(int fd, uid_t uid, gid_t gid);
  ```
- **修改日期**：
  ```c
  int utime(const char *path, const struct utimbuf *buf);
  ```
  - `struct utimbuf` 包含：
    - `actime`：最后访问时间
    - `modtime`：数据最后修改时间

---

## 4. 目录

### 什么是目录？
- **目录**是磁盘上的一种特殊文件。
- 目录的类型与常规文件不同，部分操作对目录有特殊限制（例如，不能用 `open("dir", O_WRONLY)`）。
- 目录的结构仍然是线性字节序列，但内核对其有自己的管理结构。
- 目录内容：对文件（常规文件或其他目录等）的引用。

### 目录的结构
#### 原始 Unix 目录结构（V7, 1977）
每个目录条目包含：
- **inode号**：文件在磁盘上的编号
- **名称**：最多14个字符
- **特殊条目**：
  - `.`：当前目录
  - `..`：父目录

#### inode 的作用
- 每个文件（包括目录）都有一个 inode，包含文件的属性和数据存储位置。
- inode 按顺序排列在磁盘的某个部分，通过 inode 号定位文件。
- 根目录的 inode 号通常为 2。
- inode 号唯一标识一个文件，包含属性和内容。

### 目录的逻辑与物理结构
- **逻辑结构**：目录形成树形结构，表现为目录和文件的层级关系。
- **物理结构**：目录条目在磁盘上按 inode 顺序存储。
- **命名规则**：文件名不属于文件属性，仅是目录中的一个条目。

### 查看目录结构
- 使用 `ls -i` 命令显示文件名和 inode 号：
```bash
> ls -i
2 .
2 ..
3 etc
8 usr
...
```

### 操作目录
- **主要操作**：
  - `open("/usr/include/stdio.h", ...)`：打开文件时需遍历目录。
  - 遍历目录需要有执行权限。
  - **路径**：
    - **绝对路径**：从 inode 2（根目录）开始。
    - **相对路径**：从当前目录的 inode 开始。
  - **删除条目**：将 inode 号设为 0，不移动其他条目。
  - **添加条目**：寻找可用位置或扩展目录。

#### 创建与删除目录
- **创建目录**：
  ```c
  int mkdir(const char *path, mode_t mode);
  ```
  - 自动创建 `.` 和 `..`。
  - `mode` 设置目录权限，通常为 `0777`（受创建掩码影响）。
- **删除目录**：
  ```c
  int rmdir(const char *path);
  ```
  - 只能删除空目录（除 `.` 和 `..` 之外）。

### 目录的改进
1982年，伯克利大学发布的BSD 4.2改进了文件系统，提升了性能和功能，增加了文件名的最大长度（最多255个字符）。

### 读取目录内容
#### 原始方法
- 使用 `open` 打开目录。
- 逐条读取 inode 号和文件名。
- 忽略 inode 号为0的条目，直到目录末尾。

#### BSD的方法
- BSD引入了新的系统调用 `getdirentries`，但该调用未被POSIX标准化，建议使用POSIX标准化的库函数：
  - `opendir`
  - `readdir`
  - `closedir`

#### 使用POSIX库函数读取目录
```c
DIR *opendir(const char *path);
struct dirent *readdir(DIR *dp);
int closedir(DIR *dp);
```
- **结构体 `dirent`**：
  - `d_ino`：inode号
  - `d_name`：文件名，以空字符结束
- **注意**：`readdir` 可能包含未标准化的字段，如 `d_type`，不建议使用。
- **使用示例**：
```c
DIR *dp;
struct dirent *d;

dp = opendir("/tmp");
if (dp == NULL)
    raler("opendir");

while ((d = readdir(dp)) != NULL) {
    if (strcmp(d->d_name, ".") != 0 &&
        strcmp(d->d_name, "..") != 0) {
        printf("%ju %s\n", (uintmax_t)d->d_ino, d->d_name);
    }
}

if (closedir(dp) == -1)
    raler("closedir");
```

### 创建和删除目录
- **创建目录**：
  ```c
  int mkdir(const char *path, mode_t mode);
  ```
  - 自动创建 `.` 和 `..` 条目。
  - 设置目录权限，通常为 `0777`（受创建掩码影响）。
- **删除目录**：
  ```c
  int rmdir(const char *path);
  ```
  - 只能删除空目录（不包括 `.` 和 `..`）。

---

## 5. 链接

### 物理链接（硬链接）
- **命令**：`ln toto titi`
- **系统调用**：
  ```c
  int link(const char *old, const char *new);
  ```
- **作用**：为同一个 inode 创建多个名称。
- **特点**：
  - 增加链接数。
  - 两个名称等价，没有主次之分。
  - 不能对目录创建硬链接，以避免循环引用。

### 物理链接的限制
- 新名称必须在同一文件系统中。
- 不能对目录创建硬链接，防止目录结构中出现循环。
- 链接必须指向已存在的文件。
- 不能跨文件系统创建链接。

### 符号链接（软链接）
- **命令**：`ln -s /tmp /home/pda/temp`
- **系统调用**：
  ```c
  int symlink(const char *old, const char *new);
  ```
- **作用**：创建一个新的文件，内容为被链接文件的路径名。
- **特点**：
  - 可以链接到目录或文件。
  - 可以跨文件系统。
  - 如果目标文件不存在，符号链接仍然存在（悬挂链接）。

### 读取符号链接
- **系统调用**：
  ```c
  ssize_t readlink(const char *path, char *buf, size_t taille);
  ```
  - 将符号链接的目标路径写入 `buf`。
  - `taille` 为缓冲区大小，可能会截断。
  - 返回写入字节数或 -1。

### `stat` 与 `lstat`
- **`stat`**：
  - 对符号链接，返回链接指向的文件属性。
  - 如果链接指向不存在的文件，返回错误。
- **`lstat`**：
  - 返回符号链接本身的属性。
  - 可以用来检测文件是否为符号链接。
- **示例**：使用 `tar` 打包时，符号链接会被打包为链接本身，而不是其指向的文件。

---
