 ### **题目 5.5**

1. 实现一个函数 **`getchar`**，该函数从标准输入中读取一个字符并返回。  
   - 如果读取到文件末尾（EOF），返回常量 **`EOF`**。  
   - 请说明 **`EOF`** 的可能数值。

2. 编写一个测试程序：
   - 主函数从标准输入中使用自定义的 **`getchar`** 函数逐个读取字符。
   - 使用标准库的 **`putchar`** 函数将这些字符逐个写入标准输出。
   - 测试程序时，将标准输入重定向到一个大文件（建议使用一个二进制文件，例如 `/bin` 目录下的程序文件之一），将标准输出重定向到一个新文件。

3. 用 **`cmp`** 命令比较原始文件和输出文件：
   - 如果 **`cmp`** 没有输出任何内容，则说明文件复制完全一致。


以下是实现和测试 `getchar` 函数的完整代码，符合题目要求。

---

### **代码实现**

```c
#include <unistd.h>
#include <stdio.h>

#define EOF (-1)  // EOF 通常定义为 -1

// 实现 getchar 函数
int getchar_custom() {
    char c;
    ssize_t result = read(STDIN_FILENO, &c, 1);  // 从标准输入读取一个字节
    if (result == 1) {
        return (unsigned char)c;  // 返回读取的字符
    } else {
        return EOF;  // 如果到达文件末尾或发生错误，返回 EOF
    }
}

// main 函数：测试 getchar_custom 并将字符写入标准输出
int main() {
    int c;
    while ((c = getchar_custom()) != EOF) {  // 使用自定义的 getchar
        putchar(c);  // 使用标准库的 putchar 将字符写入标准输出
    }
    return 0;
}
```

---

### **代码说明**

1. **自定义 `getchar_custom` 函数：**
   - 使用 `read` 从标准输入 (`STDIN_FILENO`) 中读取 1 字节。
   - 如果读取成功，返回字符的值（需要将其转为 `unsigned char` 避免符号扩展问题）。
   - 如果到达文件末尾（`read` 返回 0）或出现错误（`read` 返回 -1），返回 `EOF`。

2. **定义 `EOF` 常量：**
   - `EOF` 是一个负值，通常定义为 `-1`。

3. **测试程序：**
   - 主程序使用 `getchar_custom` 读取输入中的所有字符。
   - 使用标准库函数 `putchar` 将读取的字符写入标准输出。

---

### **编译和执行**

#### **编译程序**
```bash
gcc -o getchar_program getchar_program.c
```

#### **执行程序**
将输入标准重定向到一个文件，输出标准重定向到另一个文件：
```bash
./getchar_program < /bin/ls > output_file
```

---

### **验证结果**

1. **比较输入和输出文件：**
   使用 `cmp` 检查文件内容是否完全一致：
   ```bash
   cmp /bin/ls output_file
   ```

   - 如果 `cmp` 没有输出任何内容，说明输入文件和输出文件是相同的。

2. **示例验证：**
   - 输入：使用 `/bin/ls` 文件（或其他二进制文件）。
   - 输出：通过程序生成的 `output_file` 文件。
   - 如果 `cmp` 不输出内容，则文件复制无误，程序正常工作。

---

### **注意事项**

1. **二进制文件支持：**
   - 使用 `read` 和 `write` 操作字节流，因此程序能够正确处理二进制文件。

2. **缓冲区效率：**
   - 本实现每次处理 1 字节（单字符），在处理大文件时效率较低。如果需要更高效的实现，可以改用块读取方式。

3. **错误处理：**
   - 此实现假设输入流始终可用，未处理 `read` 返回 -1 的情况。如果需要更健壮的实现，可以添加对错误返回值的处理逻辑。

4. **文件大小限制：**
   - 本程序假定输入流可处理任意大小的文件，因为没有额外分配内存，性能和内存占用仅受操作系统的限制。