# 文件管理
Pierre David  
pda@unistra.fr  
斯特拉斯堡大学  
2024 – 2025

---

## 目录

1. 文件访问
2. 系统原语和库函数
3. 文件属性
4. 目录
5. 链接

---

## 使用许可

© Pierre David  
可在 <https://gitlab.com/pdagog/ens> 获取  
本课程幻灯片采用“[知识共享署名-非商业性使用 4.0 国际](https://creativecommons.org/licenses/by-nc/4.0/)”许可证。

---

## 第一部分：文件访问

### 文件的概念

- **文件**：
  - 具有一个或多个**名称**。
  - 通过**路径**（绝对路径或相对路径）访问。
  - 拥有**属性**：
    - 类型
    - 所有者、用户组、权限
    - 大小
    - 日期：
      - 数据的最后修改日期
      - 属性的最后修改日期
      - 最后访问日期
    - 数据在磁盘上的位置
- **文件类型**：
  - **常规文件**
  - **目录**
  - （实际上还有其他类型，后面会提到）

---

### 文件结构

- 文件具有简单的结构：**线性字节序列**

  ```
  索引: 0 1 2 3 4 5 6 ... n-1
  内容: C o u c o u
  ```

- **Unix的创新**：
  - 早期系统中，文件有特定的类型（文本、数据库等）。
  - 在Unix中，文件没有类型，这简化了内核设计。
  - 文件的结构取决于访问它的**应用程序**：
    - **文本文件**：字符序列，以`\n`（字节10）分隔。
    - **可执行二进制文件**：包含描述不同部分的头部（代码、数据、调试信息等）。
    - **LibreOffice文档**：根据LibreOffice应用程序的定义。
    - 等等。
- **魔数（Magic Number）**：
  - 文件开头的一串字节，用于标识文件类型。
  - 示例：
    - `#!`（脚本）
    - `%PDF`（PDF文件）
    - `0xffd8`（JPEG）

---

### 文件访问

- **当前路径**：

  ```shell
  $ pwd
  /home/pda
  ```

- **`file`命令**：
  - `file`命令使用各种启发式方法“猜测”文件的用途：
    - 文件类型：常规文件、目录等（稍后讨论）。
    - 魔数。
    - 字符集识别（ISO、UTF-8等）。
  - 示例：

    ```shell
    # 猜测这两个文件的内容...
    > file ch2-file.tex ch2-file.pdf
    ch2-file.tex: LaTeX 2e document, Unicode text, UTF-8 text
    ch2-file.pdf: PDF document, version 1.5

    # 以十六进制显示ch2-file.pdf的前10个字节（及字符）
    > od -t xCc -N 10 ch2-file.pdf
    0000000 25 50 44 46 2d 31 2e 35 0a 25
              %   P   D   F   -   1   .   5  \n   %
    ```

- **文件名**：
  - 对于内核来说，文件名没有特殊含义。
    - 可以将可执行文件命名为`toto.titi.tata`。
    - 可以将文本文件命名为`toto.xls`。
  - 某些应用程序期望特定的后缀：
    - 例如，C编译器假定C源文件以`.c`结尾。
  - 但这并非普遍情况。

---

## 第二部分：系统原语和库函数

### 文件打开

```c
int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
```

- 有两种形式的`open`函数（特例）：
  - **第一种形式**：简单打开文件。
  - **第二种形式**：在需要时创建文件，因此需要指定`mode`（文件的初始权限，应用创建掩码，稍后讨论）。
- 返回值：**文件描述符**（或`-1`表示失败）。
- 文件描述符用于其他原语操作。

---

### 打开文件的标志（flags）

- `flags`参数指定打开模式：

| 模式         | 含义         |
| ---------- | ---------- |
| `O_RDONLY` | 只读打开       |
| `O_WRONLY` | 只写打开       |
| `O_RDWR`   | 读写打开       |
| `O_CREAT`  | 如果文件不存在则创建 |
| `O_EXCL`   | 独占打开       |
| `O_TRUNC`  | 若文件已存在则清空  |
| `O_APPEND` | 追加模式       |

- 示例：

  ```c
  open("toto", O_RDONLY);
  // 以只读方式打开文件（文件必须存在）

  open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  // 创建新文件（或清空已存在的文件），以只写方式打开

  open("toto", O_RDWR | O_CREAT | O_APPEND, 0666);
  // 创建新文件（如果不存在），以读写方式打开，追加模式
  ```

---

### 文件关闭

- 使用`close`函数关闭文件：

  ```c
  int close(int fd);
  ```

- 使用建议：
  - **尽早关闭文件**，不要忘记。
  - 进程终止时会自动关闭文件，但最好在不需要时立即关闭。

---

### 文件读写

- **读操作**：

  ```c
  ssize_t read(int fd, void *buf, size_t nb);
  ```

- **写操作**：

  ```c
  ssize_t write(int fd, const void *buf, size_t nb);
  ```

- 返回值：传输的字节数（或`-1`表示错误），在文件末尾时返回`0`。
- 参数说明：
  - `fd`：文件描述符（由`open`返回）。
  - `buf`：缓冲区地址，用于存储读取的数据或提供要写入的数据。
  - `nb`：要传输的字节数。
- 注意：
  - 实际传输的字节数可能少于请求的字节数。
  - 示例：
    - 如果请求读取500字节，但文件只有10字节，则返回10。
    - 如果磁盘空间不足，只能写入部分数据。

---

### 文件指针移动

- 使用`lseek`函数移动文件指针：

  ```c
  off_t lseek(int fd, off_t offset, int whence);
  ```

- 每个打开的文件都有一个**偏移量**（`offset`），表示文件中的当前位置。
- `whence`参数：

  | 值          | 含义                       |
  | ----------- | -------------------------- |
  | `SEEK_SET`  | 从文件开头开始移动         |
  | `SEEK_CUR`  | 从当前位置开始移动         |
  | `SEEK_END`  | 从文件末尾开始移动         |

- 返回值：移动后的偏移量（或`-1`表示错误）。
- 示例：

  ```c
  lseek(fd, 1000000, SEEK_SET);  // 移动到文件的第1,000,000个字节处
  lseek(fd, -20, SEEK_CUR);      // 从当前位置后退20字节
  lseek(fd, 300000, SEEK_END);   // 移动到文件末尾之后300,000字节处
  lseek(fd, 0, SEEK_CUR);        // 获取当前偏移量
  ```

---

### 标准文件描述符

- **三个默认打开的文件描述符**：

  | 文件描述符 | 常量名         | 说明         |
  | ---------- | -------------- | ------------ |
  | `0`        | `STDIN_FILENO` | 标准输入     |
  | `1`        | `STDOUT_FILENO`| 标准输出     |
  | `2`        | `STDERR_FILENO`| 标准错误输出 |

- 这些描述符由Shell打开，默认指向终端。
- 可以通过重定向将其指向文件。
- **注意**：不要假设标准输入一定是键盘，标准输出一定是屏幕。

---

### 系统原语与库函数

- **系统原语**：`open`、`close`、`read`、`write`、`lseek`。
- **库函数**：`fopen`、`fclose`、`getc`、`scanf`、`fread`、`putc`、`printf`、`fwrite`、`fseek`等。
- 两者的区别：

  | 系统原语                    | 库函数                     |
  | --------------------------- | -------------------------- |
  | 文件描述符为`int`           | 文件描述符为`FILE *`       |
  | 参数较为底层，使用较复杂     | 使用更简单的函数（如`getc`、`putc`） |
  | 仅提供读或写操作            | 提供更多功能（如`printf`、`scanf`） |
  | 目的是数据的安全传输        | 旨在方便编程               |
  | 在内核中执行                | 由库实现，调用系统原语     |

---

### 效率比较

- **哪个更高效？**

  - **小数据量**：
    - 库函数更高效，因为它们使用了**缓冲**，减少了系统调用次数。
    - 示例：`getc`在缓冲区耗尽前无需再次调用`read`。
  - **大数据量**：
    - 系统原语更高效，因为可以一次性传输大量数据，避免了库函数的额外开销。

---

## 第三部分：文件属性

### 文件的属性

- **每个文件都有以下属性**：
  - 类型
  - 所有者和用户组
  - 权限
  - 大小
  - 日期：
    - 数据的最后修改日期
    - 属性的最后修改日期
    - 最后访问日期
  - 链接数（稍后讨论）
  - 设备号、inode编号
  - 数据在磁盘上的位置
- **注意**：文件名不是文件的属性（稍后讨论）。

---

### 文件日期

- 使用`ls`命令查看文件日期：

  ```shell
  $ ls -l ch1-intro.tex
  -rw-r--r-- 1 pda users 378 Jan 22 2019 ch1-intro.tex
  ```

- `ls`的选项：

  - `-c`：显示属性的最后修改日期。
  - `-u`：显示文件的最后访问日期。

  ```shell
  $ ls -lc ch1-intro.tex
  -rw-r--r-- 1 pda users 378 Jan 9 19:20 ch1-intro.tex

  $ ls -lu ch1-intro.tex
  -rw-r--r-- 1 pda users 378 Jul 8 18:37 ch1-intro.tex
  ```

---

### 文件权限

- **权限位**：12位

  ```
  位位置: 0 1 2 3 4 5 6 7 8 9 10 11
  权限位: s s t r w x r w x r w x
             |  |  |  |  |  |  |--- 其他用户权限
             |  |  |  |  |  |----- 组权限
             |  |  |  |  |------- 所有者权限
             |  |  |----------- 粘滞位（sticky bit）
             |  |------------- 设置组ID位（set-group-ID）
             |--------------- 设置用户ID位（set-user-ID）
  ```

- **解释**：

  - **所有者权限**：读（`r`）、写（`w`）、执行（`x`）。
  - **组权限**：同上。
  - **其他用户权限**：同上。
  - **特殊位**：
    - **粘滞位（sticky bit）**：对于目录，只有文件的所有者或目录的所有者才能删除或重命名其中的文件（如`/tmp`目录）。
    - **设置用户ID位（set-user-ID）**：执行文件时，进程的有效用户ID将被设置为文件所有者的ID。
    - **设置组ID位（set-group-ID）**：类似于设置用户ID位，但针对组ID。

---

### 获取文件属性

- 使用`stat`或`fstat`函数：

  ```c
  int stat(const char *path, struct stat *stbuf);
  int fstat(int fd, struct stat *stbuf);
  ```

- `struct stat`结构体包含：

  - `st_mode`：文件类型和权限。
  - `st_uid`：文件所有者的用户ID。
  - `st_gid`：文件所属组的组ID。
  - `st_size`：文件大小（字节数）。
  - `st_atime`：最后访问时间。
  - `st_mtime`：最后修改时间（数据）。
  - `st_ctime`：最后状态改变时间（属性）。

---

### 解释`st_mode`

- **`st_mode`包含类型和权限信息**：

  ```
  位位置: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
  内容:   类型位 s s t r w x r w x r w x
                 |  |  |  |  |  |  |--- 其他用户权限
                 |  |  |  |  |  |----- 组权限
                 |  |  |  |  |------- 所有者权限
                 |  |  |----------- 粘滞位
                 |  |------------- 设置组ID位
                 |--------------- 设置用户ID位
  ```

- **提取权限和类型**：

  - **权限**：`stbuf.st_mode & 0777`
  - **类型**：`stbuf.st_mode & S_IFMT`

- **使用宏定义判断文件类型**：

  ```c
  if (S_ISDIR(stbuf.st_mode)) {
      // 是目录
  }

  if (S_ISREG(stbuf.st_mode)) {
      // 是常规文件
  }
  ```

---

### 修改文件属性

- **修改权限**：

  ```c
  int chmod(const char *path, mode_t mode);
  int fchmod(int fd, mode_t mode);
  ```

- **修改所有者或组**：

  ```c
  int chown(const char *path, uid_t uid, gid_t gid);
  int fchown(int fd, uid_t uid, gid_t gid);
  ```

- **修改时间戳**：

  ```c
  int utime(const char *path, const struct utimbuf *buf);
  ```

  - `struct utimbuf`包含：

    - `actime`：最后访问时间。
    - `modtime`：最后修改时间。

---

### 权限检查

- **使用`access`函数检查权限**：

  ```c
  int access(const char *path, int mode);
  ```

- `mode`参数：

  - `F_OK`：检查文件是否存在。
  - `X_OK`：执行权限。
  - `W_OK`：写权限。
  - `R_OK`：读权限。

- 返回值：

  - `0`：有权限。
  - `-1`：无权限。

---

## 第四部分：目录

### 目录的概念

- **目录也是一种文件**，但具有特殊的类型和结构。
- **限制**：

  - 不能对目录执行某些操作，例如`open("directory", O_WRONLY)`。

- **结构**：

  - 虽然也是字节序列，但内核以自己的结构存储目录内容。
  - 包含对其他文件（常规文件或目录）的引用。

---

### 目录的结构（Unix V7，1977年）

- **原始结构**：

  ```
  每个目录项：
  - inode编号（2字节）
  - 文件名（14字节）
  ```

- 包含特殊的目录项：

  - `.`：当前目录。
  - `..`：父目录。

---

### inode（索引节点）

- **inode的作用**：

  - 每个文件（常规文件或目录）都有一个inode，包含文件的属性和数据位置。
  - inodes在磁盘上的特定区域顺序存储。

- **inode编号**：

  - 标识文件的唯一编号。
  - 根目录的inode编号通常为2。

---

### 目录的实现

- **目录是一个包含目录项的文件**，每个目录项包括文件名和inode编号。

- **文件系统的逻辑视图和实现示例**：

  - 逻辑视图：

    ```
    /
    ├── usr
    │   ├── bin
    │   ├── include
    │   │   ├── stdio.h
    │   │   └── unistd.h
    │   └── lib
    └── home
    ```

  - 实现中，通过inode编号和目录项实现这种结构。

---

### 遍历目录

- **打开文件**：`open("/usr/include/stdio.h", ...)`
  - 需要遍历目录，检查每一级目录是否有执行权限。

- **删除目录项**：
  - 使用`unlink`或`rmdir`（对于目录）。

- **添加目录项**：
  - 在目录中添加新的文件名和inode编号对。

---

### 目录的读取

- **使用`opendir`、`readdir`和`closedir`函数读取目录**：

  ```c
  DIR *opendir(const char *path);
  struct dirent *readdir(DIR *dp);
  int closedir(DIR *dp);
  ```

- **`struct dirent`结构体**：

  - `d_ino`：inode编号。
  - `d_name`：文件名。

- **示例**：

  ```c
  DIR *dp;
  struct dirent *d;

  dp = opendir("/tmp");
  if (dp == NULL) {
      perror("opendir");
      exit(EXIT_FAILURE);
  }

  while ((d = readdir(dp)) != NULL) {
      printf("%ju %s\n", (uintmax_t)d->d_ino, d->d_name);
  }

  closedir(dp);
  ```

---

### 创建和删除目录

- **创建目录**：

  ```c
  int mkdir(const char *path, mode_t mode);
  ```

  - 自动创建`.`和`..`目录项。
  - `mode`指定目录的权限。

- **删除目录**：

  ```c
  int rmdir(const char *path);
  ```

  - 只能删除空目录（除了`.`和`..`）。

---

## 第五部分：链接

### 硬链接（物理链接）

- **创建硬链接**：

  ```c
  int link(const char *oldpath, const char *newpath);
  ```

  - `ln`命令：`ln toto titi`
  - 为`oldpath`添加一个新的名称`newpath`。

- **实现**：

  - 增加一个指向同一inode的目录项。
  - 增加文件的链接计数（`st_nlink`）。

- **限制**：

  - 必须在同一文件系统内。
  - 不能对目录创建硬链接（防止循环引用）。

---

### 符号链接（软链接）

- **创建符号链接**：

  ```c
  int symlink(const char *target, const char *linkpath);
  ```

  - `ln -s /tmp /home/pda/temp`
  - 符号链接是包含目标路径名的特殊文件。

- **特点**：

  - 可以跨文件系统。
  - 可以指向不存在的目标。
  - 可以指向目录。

- **读取符号链接**：

  ```c
  ssize_t readlink(const char *path, char *buf, size_t bufsiz);
  ```

  - 读取符号链接的内容（目标路径）。

- **注意`stat`和`lstat`的区别**：

  - `stat`：获取符号链接指向的文件的属性。
  - `lstat`：获取符号链接本身的属性。

---

---

**总结**：本课程涵盖了Unix/Linux系统中关于文件管理的基本概念和操作，包括文件的访问方式、系统原语与库函数的区别、文件的属性以及如何修改、目录的结构和操作，以及硬链接和符号链接的实现与区别。

---