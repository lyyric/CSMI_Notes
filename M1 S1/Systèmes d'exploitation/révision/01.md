## 课程介绍

### 课程大纲
1. **课程组织**
2. **从最早的计算机到操作系统**
3. **内核**
4. **POSIX标准**
5. **追踪系统调用**

---

## 1. 课程组织

### 课程核心主题
本课程的核心主题是**如何使用操作系统**。具体内容包括：
- **底层操作**：使用C语言调用系统原语，需要具备良好的C语言基础。
- **POSIX原语**：了解国际标准POSIX，确保程序的可移植性。
- **系统概念理解**：深入理解操作系统管理的概念，如进程、用户、文件等。
- **目标**：明确操作系统的边界及其管理的核心概念，并通过实际操作加深理解。

### 实验部分
课程将通过实践课来巩固理论知识，包括：
- 使用系统原语进行编程
- 大量练习以熟悉操作系统的基本概念

### 参考书目
- M. Rochkind, 《Unix高级编程》，Dunod出版社，1991年
- W.R. Stevens & S.A. Rago, 《UNIX环境下的高级编程（第3版）》，Addison-Wesley出版社，2013年
- IEEE计算机协会 & The Open Group, 《信息技术-可移植操作系统接口（POSIX®）-基础规范》，IEEE标准1003.1，2017年  
  在线版本：[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)

---

## 2. 从最早的计算机到操作系统

### 什么是操作系统？
操作系统（SE）不仅仅是像Windows、Linux、FreeBSD等常见系统的总称。它还包括诸如Debian、Ubuntu、Android、iOS、QNX、RTLinux、VxWorks、Contiki、TinyOS等多种系统。此外，许多嵌入式设备如路由器、终端、智能手表、恒温器、汽车等也运行着操作系统。

### 操作系统的定义
要定义操作系统，需要回顾其历史，了解其解决的需求和问题。

### 早期计算机示例：ENIAC（1946年）
- **编程方式**：通过物理连接电缆编程，结果通过指示灯查看。
- **特点**：
  - 成本高昂，通常只有一个实例
  - 编程困难，ENIAC最初由6名程序员编写，耗时数周
  - 只能运行一个程序，缺乏外围设备
  - **结论**：早期计算机没有操作系统

### 计算机控制板和打孔卡
- **PDP-1控制板**：通过开关输入程序，启动程序并通过指示灯读取结果。
- **打孔卡**（1950年代初）：作为程序和数据的输入设备，程序加载到内存后执行。

### 监控程序（Monitors）与批处理
- **监控程序**：自动化多个程序的执行，支持批处理（batch processing）。
- **Spooling**：利用外围设备的并行性，提高计算机的利用率。例如，IBM 7094通过连接缓冲设备与磁带驱动器，实现更高效的资源管理。

### 多道程序设计（Multiprogramming）
- **目的**：在程序等待输入/输出（I/O）时，利用处理器执行其他程序，提升资源利用率。
- **实现**：操作系统加载多个程序到内存，当一个程序请求I/O时，切换到另一个程序执行。
- **挑战**：
  - 程序间的保护，防止互相访问
  - 使用中断机制控制程序切换

### 交互式操作与时间共享
- **电传打字机（Teletypes）**：改变了用户与计算机的交互方式，支持命令行操作。
- **时间共享系统**：允许多个用户同时使用计算机，每个用户分配一个时间片，用户感觉像拥有自己的计算机。
  - **例子**：CTSS（麻省理工学院，1961年）、STSS（斯坦福，1963年）

### 系统调用（System Calls）
- **定义**：程序通过特定指令（如TRAP、SVC、INT）请求操作系统服务。
- **作用**：
  - 切换到特权模式
  - 跳转到操作系统的特定地址
  - 验证参数和权限
  - 执行请求的操作

### 操作系统的功能总结
- **优化计算机使用率**：利用所有空闲时间执行任务。
- **资源共享**：公平分配内存、处理器时间、网络、磁盘空间等资源。
- **外围设备管理**：提供硬件接口，利用设备并行性。
- **用户支持**：允许用户编辑、开发和运行程序，提供必要的安全保障。

---

## 3. 内核

### Unix哲学与内核设计
Unix采用简约主义，与早期复杂的操作系统不同。内核的设计目标包括：
1. **公平共享资源**：如内存、处理器时间、网络连接、磁盘空间等。
2. **保障数据安全**：确保一个进程不能未经授权访问另一个进程的数据，用户不能访问未授权的文件或终止他人进程等。

### 内核的实现
- **特权模式**：内核以特权模式运行，拥有对所有硬件资源的访问权限。
- **用户模式**：应用程序在用户模式下运行，必须通过系统调用请求内核服务。
- **系统调用接口**：内核提供一组系统原语（系统调用）供应用程序使用，如`open`函数。

### 内核的定义
内核是实现操作系统核心功能的最小集合，负责资源管理和安全保障。

### 内核的特点
- **持续运行**：内核在系统启动时加载到内存中，直到系统关闭或重启。
- **高可靠性**：内核代码敏感且复杂，通常保持尽可能小，以减少出错概率。
- **分工明确**：例如，用户命令`ls -l`中，用户信息的转换由`ls`命令本身完成，而不是内核处理。

### 系统调用的选择
- **必须由内核处理的功能**：如文件访问（`open`）、获取系统时间（`time`）。
- **不需要内核处理的功能**：如字符串操作（`strlen`），这些功能由用户空间的库函数实现。

### 用户界面与内核
图形用户界面（如鼠标、触摸屏）由应用程序管理，而内核仅负责处理硬件设备的输入输出。

### 操作系统的整体结构
- **内核**：管理硬件资源，提供系统调用接口。
- **应用程序**：通过内核提供的接口使用系统资源，实现用户功能。

### 操作系统的扩展性
- **嵌入式系统**：实时操作系统（RTOS）和物联网设备操作系统（如Contiki、TinyOS）在内核基础上进行定制，满足特定需求。

---

## 4. POSIX标准

### POSIX简介
- **POSIX**：可移植操作系统接口（Portable Operating System Interface），由IEEE制定，国际标准为ISO/IEC 9945。
- **目的**：统一不同操作系统的接口，确保程序的可移植性。
- **重要性**：几乎所有操作系统都遵循POSIX标准，否则难以保证兼容性。

### POSIX标准内容
- **系统原语和库函数**：定义了操作系统提供的基本功能，如文件操作、进程管理等。
- **命令行工具**：标准化了常用命令，如`sh`、`ls`、`tr`等。
- **扩展功能**：包括实时处理、线程管理、信号量等。

### POSIX的数据类型
- **引入新类型**：如`uid_t`（用户ID）、`gid_t`（组ID）、`pid_t`（进程ID）、`mode_t`（权限）、`time_t`（时间）、`size_t`（大小）。
- **目的**：隐藏实现细节，增强程序的可移植性。

### 常量定义
- **使用头文件**：如`unistd.h`定义了`R_OK`、`W_OK`、`X_OK`、`F_OK`等常量，用于文件权限检查。
- **系统限制**：通过`limits.h`、`sysconf`、`pathconf`等定义路径长度、用户名长度、最大进程数等限制。

### 错误处理
- **错误返回值**：大多数系统调用在出错时返回-1，并设置`errno`变量。
- **错误描述**：使用`perror`或`strerror`函数获取错误信息。
- **推荐实践**：
  - 始终检查系统调用的返回值。
  - 使用辅助函数或宏简化错误处理，如定义`raler`函数或`CHK`宏。

### 系统调用参数
- **指针参数**：某些系统调用需要指针参数来返回复杂结果，如`stat`函数需要传入`struct stat`的指针。
- **使用示例**：
  ```c
  struct stat stbuf;
  if (stat("toto", &stbuf) == -1) {
      perror("stat toto");
      exit(1);
  }
  ```

---

## 5. 追踪系统调用

### 追踪工具
- **Linux**：使用`strace`命令。
- **FreeBSD**：使用`truss`命令。

### 使用示例
```bash
$ strace cp README test
execve("/bin/cp", ["cp", "README", "test"], 0x7ffd01453380) = 0
...
open("README", O_RDONLY) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=445, ...}) = 0
open("test", O_WRONLY|O_CREAT|O_EXCL, 0644) = 4
...
read(3, "Lorem ipsum dolor sit amet, cons...", 131072) = 445
write(4, "Lorem ipsum dolor sit amet, cons...", 445) = 445
...
close(4) = 0
close(3) = 0
...
+++ exited with 0 +++
```

### 追踪系统调用的用途
- **学习系统原语**：通过观察程序执行的系统调用，了解操作系统提供的服务。
- **理解命令工作原理**：分析简单命令的系统调用，有助于理解其内部实现。
- **区分系统原语与库函数**：系统调用由内核处理，库函数在用户空间执行，不会在追踪输出中显示。
- **调试程序**：发现程序执行流程中的问题，如程序提前退出等。

### 推荐实践
- **广泛使用**：建议经常使用`strace`或类似工具，以加深对系统调用的理解和调试能力。

---

### 总结
自Unix以来，操作系统逐渐形成了内核与用户空间的清晰分工。本课程旨在深入理解操作系统内核的工作原理，掌握POSIX标准，学会通过工具追踪系统调用，从而全面掌握操作系统的使用与开发。

---
