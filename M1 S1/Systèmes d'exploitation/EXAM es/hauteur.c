#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

#define MAX_PATH 256

void proc(char *path, char *rpath) {
    struct stat st;
    if (lstat(path, &st) < 0) {
        perror("lstat");
        exit(255);
    }
    if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
        printf("%s est une feuille\n", rpath);
        exit(0);
    } else if (S_ISDIR(st.st_mode)) {
        DIR *dir = opendir(path);
        if (dir == NULL) {
            perror("opendir");
            exit(255);
        }
        pid_t ccpids[MAX_PATH];
        int ccount = 0;
        while (1) {
            struct dirent *result = readdir(dir);
            if (result == NULL) {
                break;
            }
            struct dirent dirrr;
            dirrr = *result;
            if (strcmp(dirrr.d_name, ".") == 0 || strcmp(dirrr.d_name, "..") == 0) {
                continue;
            }
            char cpath[MAX_PATH];
            char crpath[MAX_PATH];
            if (snprintf(cpath, MAX_PATH, "%s/%s", path, dirrr.d_name) >= MAX_PATH) {
                printf("Path too long\n");
                closedir(dir);
                exit(255);
            }
            if (snprintf(crpath, MAX_PATH, "%s/%s", rpath, dirrr.d_name) >= MAX_PATH) {
                printf("Relative path too long\n");
                closedir(dir);
                exit(255);
            }
            pid_t ccpid = fork();
            switch (ccpid)
            {
            case -1:
                perror("fork");
                closedir(dir);
                exit(255);
            case 0:
                closedir(dir);
                proc(cpath, crpath);
                exit(255);
            default:
                if (ccount >= MAX_PATH) {
                    printf("Too many child processes\n");
                    closedir(dir);
                    exit(255);
                }
                ccpids[ccount++] = ccpid;
            }
        }
        if (closedir(dir) < 0) {
            perror("closedir");
            exit(255);
        }

        int maxh = -1;
        int erroroc = 0;
        for (int i = 0; i < ccount; ++i) {
            int status;
            pid_t waipid = waitpid(ccpids[i], &status, 0);
            if (waipid < 0) {
                perror("waitpid");
                exit(255);
            }
            if (WIFEXITED(status)) {
                int ecode = WEXITSTATUS(status);
                if (ecode == 255) {
                    erroroc = 1;
                } else {
                    if (ecode > maxh) {
                        maxh = ecode;
                    }
                }
            } else {
                erroroc = 1;
            }
        }
        if (erroroc) {
            exit(255);
        }
        int hauteur = maxh + 1;
        if (hauteur > 254) {
            printf("%s hauteur max atteinte\n", rpath);
            exit(254);
        } else {
            printf("%s est Ã  la hauteur %d\n", rpath, hauteur);
            exit(hauteur);
        }
    }
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s directory\n", argv[0]);
        exit(255);
    }

    char *path = argv[1];

    pid_t pid = fork();
    switch (pid)
    {
    case -1:
        perror("fork");
        exit(255);
    case 0:
        proc(path, path);
        exit(255);
    default:
        int status;
        pid_t waipid = waitpid(pid, &status, 0);
        if (waipid < 0) {
            perror("waitpid");
            exit(255);
        }
        if (WIFEXITED(status)) {
            int ecode = WEXITSTATUS(status);
            exit(ecode);
        } else {
            exit(255);
        }
    }

    return 0;
}