#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

volatile sig_atomic_t continue_working = 1;  // 全局变量，用于控制子进程的循环状态
volatile sig_atomic_t alarm_triggered = 0;  // 父进程是否收到定时信号的标志

void traite() {
    printf("子进程正在工作...\n");
}

void fin_fils(int sig) {
    printf("子进程收到 SIGUSR1 信号，正在停止运行。\n");
    continue_working = 0;  // 停止工作循环
}

void alarm_handler(int sig) {
    printf("父进程的定时器已触发。\n");
    alarm_triggered = 1;  // 设置标志
}

int main() {
    pid_t pid;
    struct sigaction sa;
    sigset_t mask, old_mask;

    pid = fork();

    switch (pid) {
        case -1:  // 错误
            perror("fork 出错");
            return 1;

        case 0:  // 子进程代码
            // 安装 SIGUSR1 信号处理器
            sa.sa_handler = fin_fils;
            sigemptyset(&sa.sa_mask);
            sa.sa_flags = 0;

            if (sigaction(SIGUSR1, &sa, NULL) == -1) {
                perror("安装 SIGUSR1 处理器时出错");
                exit(1);
            }

            // 阻塞所有信号，确保仅在 sigsuspend 时接收信号
            sigfillset(&mask);
            sigdelset(&mask, SIGUSR1);  // 允许 SIGUSR1
            sigprocmask(SIG_SETMASK, &mask, &old_mask);

            while (continue_working) {
                traite();

                // 挂起直到接收到 SIGUSR1
                sigsuspend(&old_mask);
            }

            exit(0);

        default:  // 父进程代码
            // 安装 SIGALRM 信号处理器
            sa.sa_handler = alarm_handler;
            sigemptyset(&sa.sa_mask);
            sa.sa_flags = 0;

            if (sigaction(SIGALRM, &sa, NULL) == -1) {
                perror("安装 SIGALRM 处理器时出错");
                return 1;
            }

            // 阻塞所有信号，确保仅在 sigsuspend 时接收信号
            sigfillset(&mask);
            sigdelset(&mask, SIGALRM);  // 允许 SIGALRM
            sigprocmask(SIG_SETMASK, &mask, &old_mask);

            // 设置 60 秒定时器
            alarm(60);

            // 等待定时器触发
            while (!alarm_triggered) {
                sigsuspend(&old_mask);  // 挂起等待 SIGALRM
            }

            printf("父进程完成等待，正在向子进程发送 SIGUSR1 信号。\n");
            kill(pid, SIGUSR1);

            // 等待子进程结束
            wait(NULL);
            printf("子进程已结束。程序结束。\n");
            break;
    }

    return 0;
}
