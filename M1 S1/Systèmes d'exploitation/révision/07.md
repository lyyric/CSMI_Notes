## 信号管理

### 课程大纲
1. 引言
2. 定义信号的动作
3. 信号的并发与屏蔽
4. 等待信号
5. 进程定时器
6. Fork与信号
7. 旧的原语
8. 与硬件中断的类比
9. 总结

---

## 1. 引言

### 信号的基本概念
**定义**：信号是内核通知进程发生的事件。

**示例**：
- **硬件事件**：
  - 断开连接（SIGHUP）
  - 按下CTRL+C（SIGINT）
  - 内存访问错误（SIGSEGV）
  - 非法指令（SIGILL）
  - 进程闹钟（SIGALRM）
  - 向无读者的管道写入（SIGPIPE）
- **程序动作**：
  - 用户自定义信号（SIGUSR1 和 SIGUSR2）
  - 终止信号（SIGTERM）
  - 强制终止信号（SIGKILL）

**信号表示**：每个信号由一个整数表示，通常以 `SIG*` 的形式命名。

### 信号的分类
信号可以分为三大类：
1. **硬件事件触发的信号**：由内核响应硬件事件发出。
2. **程序异常触发的信号**：由处理器检测到异常（如非法内存访问）后由内核发出。
3. **无特定语义的信号**：由进程通过 `kill` 原语主动发出。

---

## 2. 定义信号的动作

### 信号默认动作
每个信号都有一个默认的动作，当信号到达进程时，进程会执行该默认动作。这些动作包括：
- **终止进程**：如SIGINT、SIGTERM、SIGSEGV等。
- **忽略信号**：如SIGCHLD、SIGWINCH等。
- **暂停进程**：如SIGSTOP。
- **继续进程**：如SIGCONT。

**常见信号及其默认动作**：

| 信号       | 默认动作 | 是否生成core文件 | 说明            |
| -------- | ---- | ---------- | ------------- |
| SIGALRM  | 终止   | 否          | 进程闹钟          |
| SIGCHLD  | 忽略   | 否          | 子进程终止         |
| SIGCONT  | 继续   | 否          | 继续暂停的进程       |
| SIGFPE   | 终止   | 是          | 浮点异常，如除以零     |
| SIGHUP   | 终止   | 否          | 断开连接          |
| SIGINT   | 终止   | 否          | 按下CTRL+C      |
| SIGKILL  | 终止   | 否          | 强制终止，无法被捕捉或忽略 |
| SIGPIPE  | 终止   | 否          | 向无读者的管道写入     |
| SIGQUIT  | 终止   | 是          | 按下CTRL+\      |
| SIGSEGV  | 终止   | 是          | 无效内存访问        |
| SIGSTOP  | 暂停   | 否          | 暂停进程          |
| SIGTERM  | 终止   | 否          | 请求进程终止        |
| SIGTSTP  | 暂停   | 否          | 按下CTRL+Z暂停    |
| SIGUSR1  | 终止   | 否          | 用户定义信号1       |
| SIGUSR2  | 终止   | 否          | 用户定义信号2       |
| SIGWINCH | 忽略   | 否          | 窗口大小改变        |

### 修改信号的默认动作
内核默认动作不总是合适的，可以为每个信号定义特定的动作。常见的动作包括：
- **SIG_IGN**：忽略信号。
- **SIG_DFL**：使用默认动作。
- **自定义处理函数**：在信号到达时执行特定的函数。

### 使用 `sigaction` 定义信号动作
```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

void handler(int sig) {
    printf("收到信号 %d\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;          // 指定处理函数
    sa.sa_flags = 0;                  // 默认行为
    sigemptyset(&sa.sa_mask);         // 不屏蔽其他信号

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    while (1) {
        // 程序主循环
    }

    return 0;
}
```
**注意事项**：
- 处理函数必须符合 `void f(int sig)` 的原型。
- 不要在处理函数中执行复杂操作，最好只做最基本的处理，如设置标志位。

---

## 3. 信号的并发与屏蔽

### 信号的两个时刻
1. **信号的发送**：内核向目标进程发送信号，设置进程的“待处理信号”标志。
2. **信号的处理**：进程在适当的时候检查并处理待处理信号。

### 并发问题
信号的异步处理可能会打断进程的同步部分，导致数据不一致。例如：
```c
struct compteur {
    uint32_t grand;
    uint32_t tresgrand;
} c = {0, 0};

void incrementer() {
    if (c.grand == UINT32_MAX) {
        c.grand = 0;
        c.tresgrand++;
    } else {
        c.grand++;
    }
}

void handler(int sig) {
    incrementer();
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);

    while (1) {
        incrementer();
    }

    return 0;
}
```
**问题**：
- 如果在 `incrementer` 执行中途接收到信号，可能会导致 `c.grand` 和 `c.tresgrand` 的不一致。

### 解决并发问题：屏蔽信号
通过屏蔽信号，可以防止在关键代码段被信号打断。

**使用 `sigprocmask` 屏蔽信号**：
```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

volatile sig_atomic_t arret = 0;

void f(int sig) {
    arret = 1;
}

int main() {
    struct sigaction sa;
    sa.sa_handler = f;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);

    sigset_t new, old;
    sigemptyset(&new);
    sigaddset(&new, SIGINT);
    sigprocmask(SIG_BLOCK, &new, &old); // 屏蔽SIGINT

    // 关键代码
    while (!arret) {
        // 执行任务
    }

    sigprocmask(SIG_SETMASK, &old, NULL); // 恢复信号屏蔽

    return 0;
}
```
**推荐**：
- 尽量缩短屏蔽信号的时间，避免长时间屏蔽导致信号积压。

---

## 4. 等待信号

### 等待信号的方法

#### 等待活跃（错误方法）
通过循环不断检查信号标志位，称为“等待活跃”。
```c
volatile sig_atomic_t signal_recu = 0;

void f(int sig) {
    signal_recu = 1;
}

int main() {
    struct sigaction sa;
    sa.sa_handler = f;
    sigaction(SIGINT, &sa, NULL);

    while (!signal_recu)
        ; // 空循环，等待信号

    // 处理信号
    return 0;
}
```
**缺点**：
- 进程持续占用CPU资源，效率低下，不环保。

#### 等待被动（正确方法）
通过系统调用将进程置于休眠状态，等待信号到达。
- **使用 `sigsuspend`**：
  ```c
  #include <stdio.h>
  #include <signal.h>
  #include <unistd.h>
  #include <stdlib.h>

  volatile sig_atomic_t arret = 0;

  void f(int sig) {
      arret = 1;
  }

  int main() {
      struct sigaction sa;
      sa.sa_handler = f;
      sa.sa_flags = 0;
      sigemptyset(&sa.sa_mask);
      sigaction(SIGINT, &sa, NULL);

      sigset_t vide;
      sigemptyset(&vide);

      while (!arret) {
          sigsuspend(&vide); // 休眠，等待信号
      }

      // 处理信号
      printf("收到SIGINT信号，退出。\n");
      return 0;
  }
  ```
**优点**：
- 进程处于休眠状态，不占用CPU资源。
- 信号到达时自动唤醒进程，进行处理。

**注意**：
- `sigsuspend` 总是返回 `-1`，需要通过循环判断信号标志位。

---

## 5. 进程定时器

### 使用 `alarm` 设置定时器
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

void handler(int sig) {
    printf("闹钟到期，收到SIGALRM信号。\n");
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGALRM, &sa, NULL);

    alarm(5); // 5秒后发送SIGALRM信号

    printf("设置闹钟，等待5秒...\n");
    pause(); // 等待信号

    return 0;
}
```
**特点**：
- **功能**：在指定秒数后发送 `SIGALRM` 信号。
- **限制**：只能设置一个定时器；调用 `alarm(0)` 可取消定时器。

### POSIX定时器
为了提供更灵活和精确的定时器，POSIX引入了定时器接口，可以设置多个定时器，并指定不同的参考时钟和通知机制。

**主要函数**：
- `timer_create`：创建定时器。
- `timer_settime`：设置定时器时间。
- `timer_gettime`：获取定时器剩余时间。
- `timer_getoverrun`：获取错过的通知次数。
- `timer_delete`：删除定时器。

**示例代码**：
```c
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>

void handler(int sig, siginfo_t *si, void *uc) {
    printf("定时器到期，信号：%d\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = handler;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIGRTMIN, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    timer_t timerid;
    struct sigevent sev;
    memset(&sev, 0, sizeof(struct sigevent));
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIGRTMIN;

    if (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1) {
        perror("timer_create");
        exit(EXIT_FAILURE);
    }

    struct itimerspec its;
    its.it_value.tv_sec = 5;      // 5秒后触发
    its.it_value.tv_nsec = 0;
    its.it_interval.tv_sec = 0;   // 不重复
    its.it_interval.tv_nsec = 0;

    if (timer_settime(timerid, 0, &its, NULL) == -1) {
        perror("timer_settime");
        exit(EXIT_FAILURE);
    }

    printf("设置POSIX定时器，等待5秒...\n");
    pause(); // 等待信号

    timer_delete(timerid);
    return 0;
}
```
**优点**：
- 支持多个定时器。
- 精度高，可达到纳秒级。
- 灵活的通知机制，可以选择信号或回调函数。

---

## 6. Fork与信号

### Fork后信号的继承
在调用 `fork` 时，子进程会继承父进程的一些信号属性：
- **继承的属性**：
  - 每个信号的动作（默认动作、自定义处理函数、忽略）。
  - 当前的信号屏蔽集（被屏蔽的信号）。
- **不继承的属性**：
  - 待处理的信号（信号不会从父进程传递给子进程）。

### 注意事项
- **信号处理函数的继承**：子进程继承父进程为信号设置的处理函数。
- **避免竞争条件**：
  - 父进程在 `fork` 前应设置好信号处理函数和屏蔽信号，防止子进程接收到未处理的信号。
  - 如果父进程和子进程都可能发送信号，需明确信号发送的时序和处理。

**示例代码**：
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

void handler(int sig) {
    printf("收到信号 %d\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程
        printf("子进程发送SIGUSR1信号给父进程。\n");
        kill(getppid(), SIGUSR1);
        exit(0);
    } else {
        // 父进程
        printf("父进程等待信号...\n");
        pause(); // 等待信号
        printf("父进程接收到信号，继续执行。\n");
    }

    return 0;
}
```

---

## 7. 旧的原语

### 旧的信号处理原语
Unix早期信号处理接口较为简单，现在已被POSIX标准的信号处理机制所取代，但仍然存在并被标准化。

**旧的原语**：
- **`signal` 函数**：
  ```c
  void (*signal(int sig, void (*handler)(int)))(int);
  ```
  - **功能**：设置信号的处理函数。
  - **缺点**：行为不一致，不支持高级功能，如信号屏蔽和复位。

- **`pause` 函数**：
  ```c
  int pause(void);
  ```
  - **功能**：使进程休眠，直到接收到一个信号。
  - **缺点**：无法指定要等待的信号，存在竞态条件。

### 为什么不推荐使用旧的原语
- **不够灵活**：无法精确控制信号屏蔽和处理。
- **存在竞态条件**：例如在设置信号处理函数和等待信号之间可能漏掉信号。
- **行为不一致**：不同系统对旧的信号接口有不同的实现。

**推荐使用**：
- **`sigaction` 和 `sigsuspend`**：提供更强大和一致的信号处理机制。

---

## 8. 与硬件中断的类比

### 硬件中断的基本机制
1. **中断发生**：外部设备完成操作后，通过中断信号通知处理器。
2. **处理中断**：
   - 保存当前进程的上下文（程序计数器、堆栈指针、状态寄存器）。
   - 切换到内核模式，执行中断处理程序。
   - 中断处理程序识别中断源，执行相应的处理。
3. **恢复执行**：中断处理完成后，恢复被中断进程的上下文，继续执行。

### 信号与硬件中断的类比
- **发起者**：
  - 硬件中断：外部设备（如键盘、网络卡）。
  - 信号：内核或其他进程。
- **目标**：
  - 硬件中断：处理器（内核）。
  - 信号：进程。
- **处理过程**：
  - 硬件中断：中断处理程序。
  - 信号：信号处理函数。
- **屏蔽机制**：
  - 硬件中断：处理器的中断屏蔽寄存器。
  - 信号：进程的信号屏蔽集。

### 总结类比
| 特性           | 中断                            | 信号                            |
|----------------|---------------------------------|---------------------------------|
| 发起者         | 硬件设备                        | 内核或其他进程                   |
| 目标           | 处理器（内核）                    | 进程                             |
| 处理机制       | 中断处理程序                      | 信号处理函数                     |
| 屏蔽机制       | 中断屏蔽寄存器                    | 信号屏蔽集                       |

---

## 9. 总结

### 进程的信号相关属性
每个进程维护以下信号相关属性：
- **信号动作表**：每个信号对应一个动作（默认动作、忽略、处理函数）。
- **信号屏蔽集**：当前被屏蔽的信号集合。
- **待处理信号集**：当前等待处理的信号集合。

### 信号处理的两步机制
1. **信号的发送**：
   - 内核向目标进程发送信号，设置待处理信号位。
2. **信号的处理**：
   - 当进程从内核返回用户态时，检查待处理信号。
   - 如果信号未被屏蔽，执行对应的信号动作。
   - 清除信号的待处理位。

### 推荐实践
- **使用 `sigaction` 定义信号处理**：提供更可靠和灵活的信号处理机制。
- **避免等待活跃**：使用 `sigsuspend` 等系统调用实现被动等待，节省资源。
- **正确屏蔽信号**：在关键代码段屏蔽相关信号，防止并发问题。
- **简化信号处理函数**：在信号处理函数中只做必要的操作，如设置标志位，避免复杂逻辑。

---



### 1.7 信号

信号是一种类似于硬件中断的机制。它们允许进程对外部事件（如按下中断键、断开连接等）或由其他进程引发的事件做出反应。

通过 `sigaction` 原语，进程可以选择对后续事件的反应类型：
- 忽略信号；
- 执行系统默认定义的操作（通常是终止进程）；
- 或者中断程序的执行以运行用户定义的函数，函数执行完毕后返回到程序。

#### 主要的信号包括：
- **SIGHUP**：断开连接  
- **SIGINT**：中断（中断键 `[BREAK]`）  
- **SIGQUIT¹**：终止（键 `[CTRL]` + `[\\]`）  
- **SIGILL¹³**：非法指令  
- **SIGTRAP¹³**：跟踪陷阱  
- **SIGIOT¹**：IOT 指令  
- **SIGEMT¹**：EMT 指令  
- **SIGFPE¹**：浮点运算异常  
- **SIGKILL⁴**：强制终止（无法屏蔽或捕获）  
- **SIGBUS¹**：内存错误  
- **SIGSEGV¹**：段错误  
- **SIGSYS**：系统调用参数错误（未使用）  
- **SIGPIPE**：向无读者的管道写入数据  
- **SIGALRM**：定时器超时  
- **SIGTERM**：软件终止信号  
- **SIGUSR1**：用户定义信号1  
- **SIGUSR2**：用户定义信号2  
- **SIGCLD²**：子进程终止  
- **SIGPWR³²**：电压下降  

**备注**：  
1. 可以将内存镜像保存到名为 `core` 的文件中。  
2. 默认操作是忽略信号，而不是终止进程。  
3. 信号到达时，不会重置为默认操作。  
4. 此信号无法忽略或处理。

如果信号在某些阻塞原语（如 `read` 或 `wait`）执行期间发生（并导致跳转到某个函数），原语可能返回错误（`errno = EINTR`），或根据情况数据传输可能被缩短。

---

### **sigaction — 操作与信号关联的动作**  
```c
#include <signal.h>
int sigaction (int sig, const struct sigaction *newact, struct sigaction *oldact);
```

- **`sigaction` 原语** 用于获取或修改与信号 `sig` 关联的动作。  

**`struct sigaction` 结构体：**  

| 类型              | 名称           | 描述                                                |
| --------------- | ------------ | ------------------------------------------------- |
| `void (*)(int)` | `sa_handler` | 信号的处理动作：                                          |
|                 |              | - `SIG_DFL`：执行默认动作（通常是终止进程）；                      |
|                 |              | - `SIG_IGN`：忽略信号；                                 |
|                 |              | - 函数地址：接收到 `sig` 信号时，执行该函数，信号编号作为参数传入。            |
| `sigset_t`      | `sa_mask`    | 在执行信号处理函数期间要阻塞的信号集合（除 `sig` 外的其他信号）。              |
| `int`           | `sa_flags`   | 信号行为标志：                                           |
|                 |              | - `SA_RESETHAND`：执行函数后重置为默认动作。                    |
|                 |              | - `SA_NODEFER`：执行函数期间不屏蔽 `sig` 信号。                |
|                 |              | - `SA_RESTART`：信号中断的系统调用自动重启（若允许）。                |
|                 |              | - `SA_NOCLDWAIT`：若 `sig = SIGCHLD`，子进程终止不会变为僵尸进程。 |

- `newact`：指向新操作的结构体。  
- `oldact`：若不为 `NULL`，存储信号原有的操作。  
- 返回：成功返回 `0`，失败返回 `-1`。

---

### **sigprocmask — 修改信号屏蔽掩码**  
```c
#include <signal.h>
int sigprocmask (int how, const sigset_t *newmask, sigset_t *oldmask);
```
- **`how` 参数说明：**  
  - `SIG_BLOCK`：将 `newmask` 指定的信号添加到当前掩码中。  
  - `SIG_UNBLOCK`：从当前掩码中移除 `newmask` 中指定的信号。  
  - `SIG_SETMASK`：将当前掩码替换为 `newmask`。  

- `newmask`：指向新的掩码。  
- `oldmask`：若不为 `NULL`，存储旧的信号掩码。  
- 返回：成功返回 `0`，失败返回 `-1`。

---

### **sigpending — 查询待处理信号**  
```c
#include <signal.h>
int sigpending (sigset_t *set);
```
- 填充 `set` 指向的区域，包含当前阻塞且待处理的信号。  
- 返回：成功返回 `0`，失败返回 `-1`。

---

### **sigsuspend — 挂起进程，等待信号**  
```c
#include <signal.h>
int sigsuspend (const sigset_t *mask);
```
- 将信号掩码临时替换为 `mask`，并挂起进程直到接收到一个信号。  
- 处理完信号后，恢复原有掩码。  
- 返回：始终返回 `-1`（表示被信号中断）。

---

### **kill — 向进程发送信号**  
```c
#include <signal.h>
int kill (pid_t pid, int sig);
```
- **`pid` 参数说明：**  
  - `pid > 0`：向指定进程发送信号。  
  - `pid = 0`：向与当前进程同组的所有进程发送信号。  
  - `pid = -1`：向所有拥有相同有效用户ID的进程发送信号。  
  - `pid < -1`：向组ID等于 `|pid|` 的所有进程发送信号。  

- 返回：成功返回 `0`，失败返回 `-1`。

---

### **signal — 旧版信号处理函数（不推荐使用）**  
```c
#include <signal.h>
void (* signal (int sig, void (*handler)(int)))(int);
```
- 允许为 `sig` 信号设置新的处理函数 `handler`。  
- 返回：成功返回原有处理函数的地址，失败返回 `SIG_ERR`。

---

### **pause — 旧版挂起函数（不推荐使用）**  
```c
#include <unistd.h>
int pause (void);
```
- 挂起进程直到接收到一个信号。  
- 返回：始终返回 `-1`。