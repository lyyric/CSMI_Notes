#include <stdio.h>
#include <stdarg.h>
#include <stdnoreturn.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

#define SIZE 1024

#define CHK(op) do { if ((op) == -1) raler (1, #op); } while (0)
#define CHKN(op) do { if ((op) == NULL) raler (1, #op); } while (0)


noreturn void raler (int syserr, const char *msg, ...)
{
    va_list ap;

    va_start (ap, msg);
    vfprintf (stderr, msg, ap);
    fprintf (stderr, "\n");
    va_end (ap);

    if (syserr == 1)
        perror ("");

    exit (EXIT_FAILURE);
}

volatile sig_atomic_t alrame_fils = 0; 
volatile sig_atomic_t msg_pere = 0; 
volatile sig_atomic_t alarme_pere = 0; 


void traite (int sig){
    (void) sig; 
    alrame_fils = 1;
    printf("fils: one second :)\n");
    return; 
}

void alarm_pere (int sig){
    (void) sig; 
    printf("pere: c'est fini :)\n");
    alarme_pere = 1;
    return; 
}

void sigusr1_fils (int sig){
    (void) sig; 
    printf("fils: c'est fini :(\n");
    msg_pere = 1; 
    return; 
}

int main() {
   struct sigaction sig; 
   sigset_t mask, empty;
   pid_t p; 

   CHK(sigemptyset(&empty));

   sig.sa_flags = 0; 
   sig.sa_handler = sigusr1_fils; 
   CHK(sigemptyset(&sig.sa_mask));
   CHK(sigaddset(&sig.sa_mask, SIGALRM)); 
   CHK(sigaction(SIGUSR1, &sig, NULL)); 

   switch (p = fork())
   {
   case -1:
        raler(1, "erreur fork()"); 

    case 0:
        sig.sa_handler = traite; 
        CHK(sigemptyset(&sig.sa_mask));
        CHK(sigaction(SIGALRM, &sig, NULL));

        CHK(sigemptyset(&mask));
        CHK(sigaddset(&mask, SIGUSR1)); 
        CHK(sigaddset(&mask, SIGALRM)); 
       
        alarm(1);  

        while (msg_pere == 0){
            CHK(sigprocmask(SIG_BLOCK, &mask, NULL)); 
            if(alrame_fils == 0 && msg_pere == 0){
                sigsuspend(&empty);
                if (errno != EINTR)
                    raler(1, "sigsuspend"); 
            }
            alrame_fils = 0;
            CHK(sigprocmask(SIG_UNBLOCK, &mask, NULL)); 
            alarm(1);   
        }

        exit(0); 
    
   default:
        sig.sa_handler = alarm_pere; 
        CHK(sigemptyset(&sig.sa_mask));
        CHK(sigaction(SIGALRM, &sig, NULL));

        CHK(sigemptyset(&mask));
        CHK(sigaddset(&mask, SIGALRM)); 
        CHK(sigprocmask(SIG_BLOCK, &mask, NULL)); 
        alarm(5);
        if (alarme_pere == 0){
            sigsuspend(&empty);
            if (errno != EINTR)
                raler(1, "sigsuspend");  
        }
        CHK(kill(p,SIGUSR1)); 
        CHK(sigprocmask(SIG_UNBLOCK, &mask, NULL)); 
   } 
    int raison;
    CHK(wait(&raison));
    if (!(WIFEXITED(raison)) || (WEXITSTATUS(raison) != 0))
        raler(0, "terminaison de processus");  


    
return 0; 

}