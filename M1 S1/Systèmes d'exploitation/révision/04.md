## 进程管理

### 课程大纲
1. 引言
2. 属性管理
3. 进程创建
4. 文件执行
5. 执行权限
6. 文件描述符重定向与共享

---
    
## 1. 引言

### 进程的定义（高层次）
- **进程定义**：进程是一个正在执行的程序的实例。
- **具体例子**：
  - 当你执行 `ls /tmp`，对应的进程是执行 `ls` 程序并使用 `/tmp` 作为参数的数据。
  - 如果另一个用户同时执行 `ls /tmp`，尽管是同一个程序和相同的数据，这也是不同的进程。
  - 即使是同一个用户执行多次相同命令，每次执行也会生成独立的进程。

### 进程的属性
一个进程拥有多个属性，包括但不限于：
- **状态**：如就绪、等待等。
- **进程标识符（PID）**。
- **父进程标识符（PPID）**。
- **所有者（UID）和群组（GID）**。
- **打开的文件描述符**。
- **当前工作目录**。
- **控制终端**。
- **内存位置**。
- **CPU时间消耗**。
- **其他属性**。

### 进程的定义（底层）
- **进程描述**：
  - **内存空间**：包含程序代码和数据。
  - **属性**：如上所述。
  - **硬件上下文**：包括处理器寄存器、地址翻译等。
- **上下文切换**：
  - 当一个进程被移出CPU时，保存其上下文（内存、寄存器等）。
  - 当一个进程被调度到CPU时，恢复其上下文。

---
    
## 2. 属性管理

### 进程内存空间
一个进程的内存空间通常分为三个区域：
1. **代码段（Text Segment）**：
   - 存放编译后的程序代码。
   - 地址从0开始未使用。
2. **数据段（Data Segment）**：
   - 存放全局变量和静态局部变量。
   - 包括通过 `malloc` 分配的堆内存。
3. **堆栈段（Stack Segment）**：
   - 存放局部变量、函数参数和返回地址。
   - 通过函数调用隐式扩展。

此外，还有：
- **共享库**：多个进程共享的代码和数据段。
- **共享内存**：不同进程之间共享的数据区域。

### 查看进程身份
#### 获取进程身份的系统调用
- **获取当前进程的PID**：
  ```c
  pid_t getpid(void);
  ```
- **获取当前进程的父进程PID**：
  ```c
  pid_t getppid(void);
  ```
- **获取当前进程的UID**：
  ```c
  uid_t getuid(void);
  ```
- **获取当前进程的GID**：
  ```c
  gid_t getgid(void);
  ```

#### 示例代码
```c
pid_t pid, ppid;
uid_t uid;
gid_t gid;

pid = getpid();
printf("我是进程 %jd\n", (intmax_t)pid);

ppid = getppid();
printf("我的父进程是 %jd\n", (intmax_t)ppid);

uid = getuid();
printf("我的所有者是 %ju\n", (uintmax_t)uid);

gid = getgid();
printf("我的群组是 %ju\n", (uintmax_t)gid);
```

### 设置进程身份
#### 设置UID和GID的系统调用
- **设置用户ID**：
  ```c
  int setuid(uid_t uid);
  ```
- **设置群组ID**：
  ```c
  int setgid(gid_t gid);
  ```
- **权限限制**：这些操作通常仅限于系统管理员（UID = 0）。

#### 用户认证流程
1. **请求登录**：用户输入登录名和密码。
2. **查找用户信息**：从 `/etc/passwd` 或 `/etc/shadow` 中查找用户信息。
3. **密码验证**：使用盐（salt）对输入密码进行加密，并与存储的加密密码比较。
4. **创建新进程**：
   - 使用 `fork` 创建一个新进程。
   - 在新进程中调用 `setuid(uid)` 和 `setgid(gid)` 设置用户和群组ID。
   - 执行用户的shell或图形界面管理器。

### 文件创建权限掩码
#### 使用 `umask` 设置文件创建权限
```c
mode_t umask(mode_t mask);
```
- **功能**：设置新创建文件的默认权限掩码。
- **权限计算**：新文件权限 = 创建模式 & ~umask。
- **推荐**：在程序中通常设置为 `0666` 或 `0777`，让用户自行管理权限。
- **注意**：
  - 若未提供 `mode` 参数，`open` 函数会从栈上读取值，可能导致不可预期的权限。
  - 使用 `umask` 命令在Shell中设置默认权限掩码。

---
    
## 3. 进程创建

### 使用 `fork` 创建进程
- **系统调用**：
  ```c
  pid_t fork(void);
  ```
- **功能**：复制当前进程，生成一个子进程。
- **特性**：
  - 子进程拥有独立的内存空间和CPU上下文。
  - 父子进程几乎完全相同，除了少数属性如PID、PPID等。
  - 子进程继承父进程的当前工作目录、打开的文件描述符等。
  
#### 示例代码
```c
pid_t v;
int x = 5;

v = fork();
x = getpid();
printf("%d\n", x);
```
- **运行结果**：
  - 父进程和子进程将分别打印不同的PID。

### `fork` 的返回值
- **返回值**：
  - **-1**：创建进程失败（如资源不足）。
  - **0**：在子进程中返回。
  - **>0**：在父进程中返回子进程的PID。
- **无确定性**：父进程和子进程谁先运行取决于调度器。

#### 使用 `fork` 的正确方式
通常需要根据 `fork` 的返回值区分父进程和子进程的行为：
```c
pid_t v;
switch (v = fork()) {
    case -1:
        // 错误处理
        raler("fork");
    case 0:
        // 子进程代码
        fils();
        exit(0);
    default:
        // 父进程代码
        ...
}
```
- **建议**：
  - 使用 `switch` 语句处理 `fork` 的三种情况（-1, 0, >0）。
  - 在子进程中调用专门的函数并使用 `exit` 终止，防止子进程继续执行父进程的代码。

### 进程终止

#### 使用 `exit` 终止进程
- **函数**：
  ```c
  void exit(int code);
  ```
- **功能**：终止当前进程，返回退出码。
- **特性**：
  - 不返回，终止进程。
  - 释放大部分资源（内存、CPU时间等）。
  - 会调用库函数中的清理操作，如刷新缓冲区、执行 `atexit` 注册的函数。
  - 内核真正的终止调用为 `_exit`，`exit` 仅为库函数封装。

#### 退出码
- **范围**：0-255。
- **约定**：
  - **0**：成功。
  - **非0**：失败，具体值可用于表示不同类型的错误。
- **示例**：
  ```c
  exit(0); // 成功
  exit(EXIT_FAILURE); // 失败
  ```
  - **注意**：`EXIT_FAILURE` 在库中定义，但Shell会将任何非0值视为失败。

#### 终止进程的系统调用
- **等待子进程终止**：
  ```c
  pid_t wait(int *status);
  pid_t waitpid(pid_t pid, int *status, int options);
  ```
- **功能**：父进程等待子进程终止，并获取其退出状态。
- **返回值**：
  - 成功：返回终止的子进程PID。
  - 失败：返回-1（如没有子进程或被信号中断）。
- **退出原因**：
  - 子进程调用 `exit`。
  - 子进程被信号终止（如 `SIGKILL`）。
  - 子进程进入暂停状态（如被调试器暂停）。
  
#### 示例代码
```c
pid_t v;
int raison;

switch (v = fork()) {
    case -1:
        raler("fork");
    case 0:
        // 子进程执行命令
        execl("/bin/echo", "echo", "a", NULL);
        raler("execl");
    default:
        // 父进程等待子进程
        if (wait(&raison) == -1)
            raler("wait");
        if (WIFEXITED(raison))
            printf("exit (%d)\n", WEXITSTATUS(raison));
        else if (WIFSIGNALED(raison))
            printf("signal %d\n", WTERMSIG(raison));
        else
            printf("其他原因\n");
}
```

### 特殊情况

#### 僵尸进程
- **定义**：已终止但未被父进程收集终止状态的进程。
- **特征**：
  - 大部分资源已释放，保留PID和终止状态。
  - 可以通过 `ps` 命令查看。
- **解决方法**：
  - 父进程调用 `wait` 或 `waitpid` 收集子进程状态，僵尸进程随之消失。

#### 孤儿进程
- **定义**：父进程终止后，子进程的父进程被重新设为 `init`（PID 1）。
- **特征**：
  - 孤儿进程会由 `init` 进程收养，并负责收集其终止状态，防止成为僵尸进程。
  - 某些Linux系统中，父进程可能是 `systemd` 而非传统的 `init`。

---
    
## 4. 文件执行

### 使用 `exec` 系列函数执行文件
- **功能**：替换当前进程的映像为新程序，不创建新进程。
- **常用函数**：
  ```c
  int execl(const char *path, const char *arg, ...);
  int execv(const char *path, char *const argv[]);
  int execle(const char *path, const char *arg, ..., char *const envp[]);
  int execve(const char *path, char *const argv[], char *const envp[]);
  int execlp(const char *file, const char *arg0, ...);
  int execvp(const char *file, char *const argv[]);
  ```
- **特性**：
  - 替换当前进程的程序和数据。
  - 保持进程ID（PID）不变。
  - 继承大部分进程属性（如UID、GID、工作目录等）。
  - 打开的文件描述符根据模式继承或关闭。
  - 成功时不返回，失败时返回-1。

### 示例代码
#### 执行 `/bin/echo` 命令
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    execl("/bin/echo", "echo", "a", "b", NULL);
    // 如果 exec 调用成功，以下代码不会执行
    perror("exec");
    return 1;
}
```

#### 使用 `fork` 和 `exec` 实现简单的Shell
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>

int main() {
    pid_t v;
    int raison;

    switch (v = fork()) {
        case -1:
            raler("fork");
        case 0:
            // 子进程执行命令
            execl("/bin/echo", "echo", "a", NULL);
            raler("execl");
        default:
            // 父进程等待子进程
            if (wait(&raison) == -1)
                raler("wait");
            if (WIFEXITED(raison) && WEXITSTATUS(raison) == 0)
                printf("ok\n");
            else
                printf("不成功\n");
    }
}
```
- **运行结果**：
  - 子进程执行 `echo a`，输出 `a`。
  - 父进程等待子进程结束，并根据退出状态输出 `ok` 或 `不成功`。

### 执行环境
- **环境变量**：
  - `exec` 函数可以传递环境变量给新程序。
  - 通过 `envp` 参数或使用 `getenv` 函数获取。
  - 环境变量由父进程继承，通常由Shell管理。
  - 使用 `export` 命令在Shell中设置环境变量。

### `exec` 的六种形式
1. **参数传递**：
   - **列表形式**：`execl("/bin/echo", "echo", "a", "b", NULL);`
   - **数组形式**：`execv("/bin/echo", argv);`
2. **路径搜索**：
   - **不搜索PATH**：如 `execv("/bin/echo", argv);`
   - **搜索PATH**：如 `execlp("echo", "echo", "a", NULL);`
3. **环境传递**：
   - **隐式传递**：`execv("/bin/echo", argv);`
   - **显式传递**：`execve("/bin/echo", argv, envp);`
   
- **系统调用 vs 库函数**：
  - `execve` 是真正的系统调用，其他形式为库函数封装。

### 魔数（Magic Numbers）
- **可执行文件**：
  - **二进制文件**：以 `0x7f 'E' 'L' 'F'` 开头（Linux下的ELF格式）。
  - **脚本文件**：以 `#!` 开头，后跟解释器路径。
- **功能**：帮助系统识别文件类型并选择适当的执行方式。

---
    
## 5. 执行权限

### 示例：权限不足时的执行
- **场景**：
  - 用户 `tata` 尝试执行属于用户 `toto` 的文件 `secret.txt`，但没有执行权限。
- **代码示例**：
  ```c
  int fd;
  fd = open("secret.txt", ...);
  if (fd == -1)
      raler("open");
  ```
- **结果**：`errno` 被设置为 `EPERM`，表示操作不被允许。

### 权限提升（Set-UID 和 Set-GID）
- **权限位**：
  - **Set-UID**：当执行文件时，进程的有效UID会变为文件所有者的UID。
  - **Set-GID**：当执行文件时，进程的有效GID会变为文件所属群组的GID。
- **用途**：
  - 允许普通用户执行需要更高权限的程序，如 `passwd` 修改密码需要写入 `/etc/passwd`。
- **示例**：
  ```bash
  $ ls -l /usr/bin/passwd
  -rwsr-xr-x 1 root root 12345 Jan 1 1970 /usr/bin/passwd
  ```
  - **解释**：`passwd` 文件的所有者是 `root`，并设置了Set-UID位，用户执行时具有 `root` 权限。

### `setuid` 和 `seteuid` 的使用
- **区分真实UID和有效UID**：
  - **真实UID**：用户实际的UID，表示是谁启动了进程。
  - **有效UID**：用于权限检查，可能与真实UID不同（如Set-UID）。
- **保存UID**：
  - 使用 `seteuid` 保存和恢复真实UID，以便在需要时切换回高权限。
  
#### 示例代码
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t pid;
    pid = fork();
    if (pid == -1) {
        raler("fork");
    } else if (pid == 0) {
        // 子进程执行需要高权限的操作
        execl("/usr/bin/passwd", "passwd", NULL);
        raler("execl");
    } else {
        // 父进程等待子进程结束
        wait(NULL);
    }
}
```

### 安全注意事项
- **避免安全漏洞**：
  - 确保Set-UID/Set-GID程序的代码安全，防止缓冲区溢出等漏洞。
  - 限制设置Set-UID/Set-GID位的可执行文件数量。
  - 严格检查用户输入，防止权限提升攻击。
  
---
    
## 6. 文件描述符重定向与共享

### Shell中的重定向
- **示例**：
  ```bash
  $ wc -l < entree > resultat 2> erreurs
  ```
  - **标准输入**（描述符0）重定向自文件 `entree`。
  - **标准输出**（描述符1）重定向到文件 `resultat`。
  - **标准错误**（描述符2）重定向到文件 `erreurs`。

### 在子进程中进行重定向
- **原则**：重定向操作应在子进程中进行，即在调用 `fork` 后，子进程在执行 `exec` 前修改文件描述符。
  
### 修改文件描述符的方法

#### 方法1：关闭并重新打开
- **步骤**：
  1. 关闭目标描述符（如 `1`）。
  2. 打开目标文件，系统会自动使用最小可用描述符（此时为 `1`）。
  
- **示例代码**：
  ```c
  if (close(1) == -1)
      raler("close");
  if (open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666) == -1)
      raler("open");
  execl("/bin/echo", "echo", "Hello", NULL);
  raler("exec");
  ```

#### 方法2：使用 `dup` 系统调用
- **功能**：复制一个已有的文件描述符，返回新的描述符。
- **示例代码**：
  ```c
  int fd;
  fd = open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  if (fd == -1)
      raler("open");
  if (close(1) == -1)
      raler("close");
  if (dup(fd) == -1)
      raler("dup");
  if (close(fd) == -1)
      raler("close");
  execv(path, tabargv);
  raler("execv");
  ```
  - **优点**：在父进程中打开文件，避免子进程因打开失败而产生额外进程。

#### 方法3：使用 `dup2` 系统调用
- **功能**：将一个文件描述符复制到指定的描述符，自动关闭目标描述符。
- **示例代码**：
  ```c
  int fd;
  fd = open("toto", O_WRONLY | O_CREAT | O_TRUNC, 0666);
  if (fd == -1)
      raler("open");
  if (dup2(fd, 1) == -1)
      raler("dup2");
  if (close(fd) == -1)
      raler("close");
  execv(path, tabargv);
  raler("execv");
  ```
  - **优点**：
    1. 自动关闭目标描述符（如 `1`）。
    2. 直接指定新描述符，简化操作。

### 文件描述符共享与重叠
- **内核数据结构**：
  - **全局文件表**：所有进程共享的文件打开记录。
  - **每个进程的文件描述符表**：记录每个进程使用的文件描述符及其对应的全局文件表项。
  
#### 示例说明
```c
int fd1 = open("toto", O_RDONLY);
int fd2 = open("toto", O_RDONLY);
dup2(fd1, 5);
read(fd1, buffer, 10); // 从偏移量25读取10字节
read(fd2, buffer, 33); // 从偏移量33读取33字节
read(5, buffer, 15);   // 从偏移量25读取15字节
```
- **解释**：
  - `fd1` 和 `5` 指向同一个全局文件表项，具有共享的偏移量。
  - `fd2` 指向另一个全局文件表项，具有独立的偏移量。

### 使用 `fork` 后的文件描述符共享
- **特性**：
  - 父子进程共享打开的文件描述符，指向相同的全局文件表项。
  - 修改文件偏移量会影响所有共享该文件描述符的进程。
  
#### 示例说明
```c
int fd = open("toto", O_RDONLY);
pid_t pid = fork();
if (pid == 0) {
    // 子进程
    read(fd, buffer, 10); // 修改偏移量
} else {
    // 父进程
    read(fd, buffer, 10); // 读取的偏移量已被子进程修改
}
```

---
    
### 总结
- **进程管理**是操作系统的核心功能之一，涉及进程的创建、执行、终止及其属性管理。
- **`fork` 和 `exec` 系列函数**是进程创建和执行的基础，通过合理使用这些函数，可以实现多进程应用和Shell等高级功能。
- **执行权限管理**通过Set-UID和Set-GID机制，实现权限提升，但需注意安全性，避免潜在漏洞。
- **文件描述符重定向与共享**允许灵活地控制进程的输入输出，实现复杂的命令行操作和进程间通信。
- **特殊进程状态**如僵尸进程和孤儿进程，需要正确处理，以维持系统的稳定和资源的有效利用。

---
