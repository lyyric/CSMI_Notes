#include <stdio.h>
#include <stdarg.h>
#include <stdnoreturn.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define CHK(op) do { if ((op) == -1) raler(1, #op); } while (0)
#define SIZE 1000

noreturn void raler(int syserr, const char *msg, ...) {
    va_list ap;
    va_start(ap, msg);
    vfprintf(stderr, msg, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    if (syserr == 1)
        perror("");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    char *nom;

    // 获取用户名
    switch (argc) {
        case 1:
            nom = getenv("USER");
            if (!nom)
                raler(0, "La variable d'environnement USER n'est pas définie");
            break;

        case 2:
            nom = argv[1];
            break;

        default:
            raler(0, "Usage: %s [nom]", argv[0]);
    }

    int ps_grep[2]; // 用于连接 `ps` 和 `grep`
    CHK(pipe(ps_grep));

    switch (fork()) {
        case -1:
            raler(1, "Échec du fork pour ps");

        case 0: // 第一个子进程执行 `ps eaux`
            CHK(close(ps_grep[0])); // 关闭管道的读端
            CHK(dup2(ps_grep[1], 1)); // 将标准输出重定向到管道的写端
            CHK(close(ps_grep[1])); // 关闭管道的写端
            execlp("ps", "ps", "eaux", (char *)NULL); // 执行 `ps eaux`
            raler(1, "Échec de execlp pour ps");
    }

    CHK(close(ps_grep[1])); // 父进程关闭管道的写端

    int grep_wc[2]; // 用于连接 `grep` 和 `wc`
    CHK(pipe(grep_wc));

    switch (fork()) {
        case -1:
            raler(1, "Échec du fork pour grep");

        case 0: // 第二个子进程执行 `grep "^<nom>"`
            CHK(dup2(ps_grep[0], 0)); // 将标准输入重定向到管道的读端
            CHK(close(ps_grep[0])); // 关闭管道的读端
            CHK(close(grep_wc[0])); // 关闭第二个管道的读端
            CHK(dup2(grep_wc[1], 1)); // 将标准输出重定向到第二个管道的写端
            CHK(close(grep_wc[1])); // 关闭第二个管道的写端

            char pattern[SIZE];
            snprintf(pattern, SIZE, "^%s", nom); // 构建正则模式
            execlp("grep", "grep", pattern, (char *)NULL); // 执行 `grep "^<nom>"`
            raler(1, "Échec de execlp pour grep");
    }

    CHK(close(ps_grep[0])); // 父进程关闭第一个管道的读端
    CHK(close(grep_wc[1])); // 父进程关闭第二个管道的写端

    // 父进程执行 `wc -l`
    CHK(dup2(grep_wc[0], 0)); // 将标准输入重定向到第二个管道的读端
    CHK(close(grep_wc[0])); // 关闭第二个管道的读端
    execlp("wc", "wc", "-l", (char *)NULL); // 执行 `wc -l`
    raler(1, "Échec de execlp pour wc");

    return 0;
}