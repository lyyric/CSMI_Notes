### 快速傅里叶变换 (FFT) 及其在多项式乘法中的应用

---

### 一、多项式表示与操作的复杂性

#### **多项式的两种表示方式**

1. **系数表示**  
   $P(x) = a_0 + a_1 x + \dots + a_{n-1} x^{n-1}$  
   使用系数数组 $(a_0, a_1, \dots, a_{n-1})$ 表示。

2. **点值表示**  
   多项式通过 $n$ 个点 $(x_0, y_0), (x_1, y_1), \dots, (x_{n-1}, y_{n-1})$ 表示，其中 $y_i = P(x_i)$。

---

#### **加法与乘法**

- **加法**：两种表示方式都很简单。
  - 系数表示直接逐项相加。
  - 点值表示也逐点相加。

- **乘法**：系数表示复杂度高，但点值表示更高效：
  - 如果 $P(x) = a_0 + a_1 x + \dots + a_{n-1} x^{n-1}$ 和 $Q(x) = b_0 + b_1 x + \dots + b_{n-1} x^{n-1}$，它们的乘积需要 $2n-1$ 个点的值来确定 $P(x) \cdot Q(x)$。
  - 点值表示中，直接计算每个点上的乘积 $P(x_i) \cdot Q(x_i)$ 即可。

---

#### **插值问题**

- 从点值表示恢复多项式（即插值）通常使用拉格朗日插值法，复杂度为 $O(n^2)$。  
- 如果我们可以快速计算多项式在一组特殊点上的值并快速进行插值，就能显著提升多项式乘法效率。

---

### 二、选择特殊点的想法

为了加速计算，我们选择**复数单位根**作为特殊点：  
$$ x_j = e^{2i\pi j / n} \quad (j = 0, 1, \dots, n-1) $$
这些点满足：  
$$ \omega_n^n = 1, \quad \omega_n^k \neq 1 \, (0 < k < n) $$

---

### 三、快速傅里叶变换 (FFT)

#### **多项式分解与递归计算**

我们将多项式 $P(x)$ 分解为偶次项和奇次项：
$$ P(x) = P^{[0]}(x^2) + xP^{[1]}(x^2), $$
其中：
$$ P^{[0]}(x) = a_0 + a_2 x + a_4 x^2 + \dots, \quad P^{[1]}(x) = a_1 + a_3 x + a_5 x^2 + \dots $$

递归计算 $P(x)$ 在点 $\omega_n^j$ 上的值，可以减少计算成本。  
通过性质：
$$ P(\omega_n^j) = P^{[0]}(\omega_{n/2}^j) + \omega_n^j P^{[1]}(\omega_{n/2}^j), $$
可以将规模为 $n$ 的问题分解为两个规模为 $n/2$ 的子问题。

---

#### **FFT 的递归实现**

1. 输入：多项式 $P(x)$ 的系数数组 $(a_0, a_1, \dots, a_{n-1})$，其中 $n = 2^k$。  
2. 输出：多项式 $P(x)$ 在点 $\omega_n^j$ 上的值。

伪代码：
```plaintext
FFT-递归(P, n):
    如果 n = 1:
        返回 P
    否则:
        设 ω_n = e^{2iπ/n}, ω = 1
        将 P 分解为：
        P^{[0]} = (a_0, a_2, ..., a_{n-2})
        P^{[1]} = (a_1, a_3, ..., a_{n-1})
        递归计算：
        y^{[0]} ← FFT-递归(P^{[0]}, n/2)
        y^{[1]} ← FFT-递归(P^{[1]}, n/2)
        合并结果：
        对 k = 0 到 n/2 - 1:
            y_k ← y_k^{[0]} + ω y_k^{[1]}
            y_{k+n/2} ← y_k^{[0]} - ω y_k^{[1]}
            ω ← ω * ω_n
        返回 y
```

---

#### **FFT 的复杂度**

设 $T(n)$ 为计算成本。递归公式为：
$$ T(n) = 2T(n/2) + O(n). $$

展开递归：
$$ T(n) = O(n \log n). $$

---

#### **快速傅里叶逆变换**

逆变换用于从点值表示恢复系数表示，公式为：
$$ a_j = \frac{1}{n} \sum_{k=0}^{n-1} y_k \omega_n^{-kj}. $$

这与 FFT 类似，只需将 $\omega_n$ 替换为 $\omega_n^{-1}$，并在最后结果上除以 $n$。

---

### 四、FFT 在多项式乘法中的应用

1. **转换为点值表示**：用 FFT 计算 $P(x)$ 和 $Q(x)$ 在点 $\omega_{2n}^j$ 上的值，复杂度 $O(n \log n)$。  
2. **点值乘法**：逐点相乘，复杂度 $O(n)$。  
3. **插值恢复系数表示**：用逆 FFT 还原乘积多项式，复杂度 $O(n \log n)$。

整体复杂度：
$$ O(n \log n). $$

---

### 五、复杂度递归关系的证明

对于递归关系：
$$ C(n) = a \cdot C\left(\frac{n}{b}\right) + f(n), $$
可通过“主定理”分析其增长速率。

#### **主定理结论**
1. 如果 $f(n) = O\left(n^{\log_b a - \epsilon}\right)$，其中 $\epsilon > 0$，则：
   $$ C(n) = \Theta\left(n^{\log_b a}\right). $$

2. 如果 $f(n) = \Theta\left(n^{\log_b a}\right)$，则：
   $$ C(n) = \Theta\left(n^{\log_b a} \cdot \log n\right). $$

3. 如果 $f(n) = \Omega\left(n^{\log_b a + \epsilon}\right)$ 且 $a \cdot f(n/b) \leq c \cdot f(n)$ （其中 $c < 1$），则：
   $$ C(n) = \Theta(f(n)). $$

---

### 六、总结

1. **FFT 复杂度**：多项式点值转换和插值的复杂度均为 $O(n \log n)$。  
2. **多项式乘法复杂度**：通过 FFT 实现的多项式乘法复杂度为 $O(n \log n)$。  
3. **主定理应用**：递归问题的复杂度分析基于主定理，适用于各种分治算法。

FFT 为科学计算、信号处理等领域提供了高效工具，在处理大规模数据时尤为重要。