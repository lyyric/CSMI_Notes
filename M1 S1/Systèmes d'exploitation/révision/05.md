## 时间管理

### 课程大纲
1. 引言
2. 当前时间
3. CPU时间
4. 文件日期
5. 进程定时器
6. 精度的演变
7. 总结

---

## 1. 引言

### 时间的测量
**问题**：操作系统内核是如何测量时间的？

### 时间测量的基本步骤
1. 获取启动时的时间
2. 计算经过的时间

---

## 2. 当前时间

### 获取启动时的时间
**方法1**：读取RTC（实时时钟）设备的时间
- **RTC（Real Time Clock）**：硬件时钟，断电时由电池供电。

**方法2**：在内核启动时请求时间
- **历史方法**：仍在某些系统中使用，如Raspberry Pi。

**方法3**：让内核启动时使用错误的时间，并通过网络同步
- **NTP（网络时间协议）**：通过网络服务器同步时间。
- **移动电话协议**：利用移动网络同步时间。

### 计算经过的时间
- **内核定期中断**：通过定期中断处理器来计算时间。
- **中断频率**：
  - **美国**：60 Hz（每秒60次中断）
  - **欧洲**：50 Hz（每秒50次中断）
- **现代系统**：使用基于石英晶体的硬件，频率可由内核编程调整，通常在每秒50到1000次中断之间（间隔1到20毫秒）。
- **计数机制**：
  - 每次中断时，内核递增一个计数器。
  - 当计数器达到设定频率时，认为一秒已过去，并递增系统时间。

---

## 3. CPU时间

### 时间单位
内核使用两种时间单位：
1. **精确时间点**：例如当前时间、文件日期等。
2. **短时间段**：例如进程消耗的CPU时间。

### `time_t` 类型
- **用途**：表示精确的时间点（以秒为单位）。
- **起点**：1970年1月1日00:00:00 UTC（称为“Epoch”）。
- **表示**：从Epoch开始的秒数。
- **历史限制**：`time_t`通常为32位，2038年将达到上限（超过2^31秒）。
- **解决方案**：转为64位表示（如Linux 3.17及以上版本）。

### `clock_t` 类型
- **用途**：表示进程消耗的CPU时间。
- **表示**：以“时钟滴答”（ticks）为单位。
- **获取频率**：
  ```c
  long freq = sysconf(_SC_CLK_TCK);
  ```
- **CPU时间测量**：每次时钟中断，内核递增当前进程的CPU时间计数器。

### 获取当前时间
#### `time` 和 `stime` 函数
- **`time_t time(time_t *heure)`**：获取当前时间。
- **`int stime(time_t *heure)`**：设置当前时间，仅限管理员使用。

#### 示例代码
```c
#include <stdio.h>
#include <time.h>

int main() {
    time_t heure;
    struct tm *tm_info;
    char s1[26], s2[30];
    
    heure = time(NULL);
    tm_info = localtime(&heure);
    
    asctime_r(tm_info, s1);
    printf("现在时间：%s\n", s1);
    
    if (strftime(s2, sizeof(s2), "日期：%d/%m/%Y 时间：%H:%M:%S", tm_info)) {
        printf("现在时间：%s\n", s2);
    } else {
        printf("s2 缓冲区太小\n");
    }
    
    return 0;
}
```

### 获取CPU时间
#### `times` 函数
- **函数原型**：
  ```c
  clock_t times(struct tms *buf);
  ```
- **功能**：获取进程及其子进程的CPU时间消耗。
- **返回值**：自某个基准时间点（如内核启动）以来的总时钟滴答数。
- **结构体 `tms`** 包含：
  - `tms_utime`：用户态CPU时间
  - `tms_stime`：内核态CPU时间
  - `tms_cutime`：子进程用户态CPU时间
  - `tms_cstime`：子进程内核态CPU时间

#### 示例代码
```c
#include <stdio.h>
#include <sys/times.h>
#include <unistd.h>

int main() {
    struct tms buffer;
    clock_t ticks = times(&buffer);
    
    if (ticks == (clock_t)-1) {
        perror("times");
        return 1;
    }
    
    printf("用户态CPU时间：%ld\n", buffer.tms_utime);
    printf("内核态CPU时间：%ld\n", buffer.tms_stime);
    printf("子进程用户态CPU时间：%ld\n", buffer.tms_cutime);
    printf("子进程内核态CPU时间：%ld\n", buffer.tms_cstime);
    
    return 0;
}
```

---

## 4. 文件日期

### 文件日期属性
使用 `stat` 和 `utime` 函数管理文件的日期属性。

#### `stat` 函数
- **函数原型**：
  ```c
  int stat(const char *path, struct stat *stbuf);
  ```
- **功能**：获取文件的属性，包括日期信息。
- **日期属性**：
  - `st_mtime`：数据最后修改时间
  - `st_ctime`：inode最后修改时间
  - `st_atime`：最后访问时间

#### `utime` 函数
- **函数原型**：
  ```c
  int utime(const char *path, const struct utimbuf *ut);
  ```
- **功能**：修改文件的访问和修改时间。
- **结构体 `utimbuf`** 包含：
  - `actime`：最后访问时间
  - `modtime`：数据最后修改时间

### 日期精度的演变
- **原始Unix**：文件日期精度到秒。
- **POSIX演进**：
  - 使用 `struct timespec` 增加纳秒精度。
  - 更新 `st_mtime`、`st_ctime` 和 `st_atime` 为 `st_mtim`、`st_ctim` 和 `st_atim`，分别为 `struct timespec` 类型。
  
#### 示例代码
```c
#include <stdio.h>
#include <sys/stat.h>
#include <time.h>

int main() {
    struct stat st;
    
    if (stat("example.txt", &st) == -1) {
        perror("stat");
        return 1;
    }
    
    printf("最后修改时间：%ld\n", st.st_mtim.tv_sec);
    printf("最后访问时间：%ld\n", st.st_atim.tv_sec);
    
    return 0;
}
```

---

## 5. 进程定时器

### 使用 `alarm` 设置定时器
- **函数原型**：
  ```c
  unsigned int alarm(unsigned int seconds);
  ```
- **功能**：在指定秒数后发送 `SIGALRM` 信号给进程。
- **限制**：
  - 只能设置一个定时器。
  - 设置为0可取消定时器。
- **默认行为**：接收到 `SIGALRM` 信号时，进程终止。

### POSIX定时器
为了克服 `alarm` 的限制，POSIX引入了更灵活的定时器接口：
- **功能**：
  - 支持多个定时器。
  - 选择定时器参考的时钟。
  - 选择通知机制（如发送信号或调用函数）。
- **主要函数**：
  - `timer_create`：创建定时器。
  - `timer_settime`：设置定时器时间。
  - `timer_gettime`：获取定时器剩余时间。
  - `timer_getoverrun`：获取错过的通知次数。
  - `timer_delete`：删除定时器。

#### 示例代码
```c
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>

void handler(int sig) {
    printf("定时器到期，信号：%d\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    
    if (sigaction(SIGALRM, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }
    
    alarm(5); // 5秒后发送SIGALRM信号
    
    printf("等待定时器...\n");
    pause(); // 等待信号
    return 0;
}
```

---

## 6. 精度的演变

### 时间测量精度的历史变化
- **1970年代**：
  - 计算机速度较慢，中断频率约为每20毫秒一次，秒级精度足够。
- **随着时间发展**：
  - 需求增加，精度需要提升到微秒甚至纳秒级。
- **POSIX标准**：
  - 引入 `clock_gettime` 等高精度时间函数。
  - 支持纳秒级别的时间测量。

### `gettimeofday` 和 `clock_gettime`
- **`gettimeofday`**：
  - **功能**：获取当前时间，精度到微秒。
  - **结构体 `timeval`**：
    - `tv_sec`：秒数。
    - `tv_usec`：微秒数。
  - **局限性**：精度到微秒，现代需求更高。

- **`clock_gettime`**：
  - **功能**：获取指定时钟的时间，精度到纳秒。
  - **结构体 `timespec`**：
    - `tv_sec`：秒数。
    - `tv_nsec`：纳秒数。
  - **时钟类型**：
    - `CLOCK_REALTIME`：真实时间。
    - `CLOCK_MONOTONIC`：单调时钟，不受系统时间调整影响。
    - `CLOCK_PROCESS_CPUTIME_ID`：进程CPU时间。
    - `CLOCK_THREAD_CPUTIME_ID`：线程CPU时间。

#### 示例代码
```c
#include <stdio.h>
#include <time.h>

int main() {
    struct timespec ts;
    
    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
        perror("clock_gettime");
        return 1;
    }
    
    printf("当前时间：%ld秒 %ld纳秒\n", ts.tv_sec, ts.tv_nsec);
    
    return 0;
}
```

---

## 7. 总结

### POSIX标准下的时间原语分类
1. **历史原语**：
   - `time`, `times`, `stat`, `utime`
   - 基于 `time_t` 和 `clock_t`
2. **基于 `struct timeval` 的原语**：
   - `gettimeofday`, `utimes`
   - 来源于伯克利大学，精度到微秒，已过时
3. **POSIX新创建的原语**：
   - `clock_gettime`, `timer_*`
   - 基于 `struct timespec`，精度到纳秒，更加持久且精确

### 选择使用哪种原语
- **常用需求**：使用历史原语（如 `time`）。
- **需要高精度**：使用POSIX新创建的原语（如 `clock_gettime`）。

---
